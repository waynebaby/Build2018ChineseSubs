1
00:00:03,316 --> 00:00:06,966
大家下午好,你们可还行?

2
00:00:07,249 --> 00:00:09,176
你们肯定想知道我拿的什么

3
00:00:10,249 --> 00:00:11,826
我是Code杂志的 吉姆 多菲雅.

4
00:00:12,496 --> 00:00:10,249
这里有我们订户吗? 杂志订阅用户? 这有哈? 好的好的

5
00:00:16,315 --> 00:00:22,798
如你所见 我们三四月份的杂志封面放了".Net 摇滚明星"四人组在上面

6
00:00:23,000 --> 00:00:32,689
我们放了Scott Gu, Scott Hanselman, Anders Hejlsberg 和Scott Hunter 在封面上

7
00:00:32,900 --> 00:00:46,859
然后我们请他们在这个全尺寸的封面海报上面签名

8
00:00:51,743 --> 00:01:01,253
好消息是我们让他们每个人都保留了一份四人签名的版本(挂在办公室墙上感觉很拉轰)之外

9
00:01:01,703 --> 00:01:06,443
我们还多准备了一份可以送给你们中的一个

10
00:01:06,443 --> 00:01:11,643
在 http://www.codemag.com/postercontest 上

11
00:01:11,643 --> 00:01:13,003
填写了所有的内容后

12
00:01:13,789 --> 00:01:18,133
你就有机会带着这张四大摇滚明星的海报回家

13
00:01:18,133 --> 00:01:24,463
这就是我要说的. 祝你们幸运!

14
00:01:24,463 --> 00:01:28,063
先生们现在舞台是你们的了

15
00:01:30,371 --> 00:01:33,733
额 这个按钮干啥用的

16
00:01:41,000 --> 00:01:46,360
哦 这切到咱这了 酷  你拿着Clicker呐? 在我这. 好的 酷

17
00:01:46,360 --> 00:01:52,140
我是Scott Hunter 我是微软的.net平台的项目管理指导

18
00:01:52,310 --> 00:01:54,310 
我是 Scott Hanselman 每次我都瞎编一个头衔

19
00:01:55,299 --> 00:01:56,579
今天弄了个指导头衔,

20
00:01:58,749 --> 00:02:03,399
我们今天内容太多时间太少估计我们得走马观花一点

21
00:02:03,389 --> 00:02:15,549
你们想多看例子不想浪费时间 我们准备了7个电脑来给你们看演示

22
00:02:15,549 --> 00:02:18,219
最少看10个演示

23
00:02:18,219 --> 00:02:21,689
有没有降低期待值? (有啊)

24
00:02:21,689 --> 00:02:30,599
在这个Session结束后有一个ch9的直播 有问题我们会在那里解答

25
00:02:30,599 --> 00:02:35,079
这是我们的大目标,

26
00:02:35,079 --> 00:02:39,429
.net 在各种东西上运行  桌面 网站 云 移动

27
00:02:39,429 --> 00:02:44,009
游戏 物联网 今天我们在这个会上还会多讲一些AI的事情

28
00:02:44,009 --> 00:02:47,419
这说明我们这个Session的观众可以用.net做所有这些事情

29
00:02:47,419 --> 00:02:48,529
你可以建造这里所有的的东西

30
00:02:48,529 --> 00:02:51,689
这是我们要传递的重要信息 也是我在Microsoft这么久的的重要原因之一

31
00:02:51,689 --> 00:02:56,269
以前我就是个c# 开发者,我喜欢c#

32
00:02:59,300 --> 00:03:00,709
可能你是F# VB的开发者,  我一开始是从WinForms开始使用的

33
00:03:00,709 --> 00:03:04,509
前面十年的时间里 在我什么都没做的情况下

34
00:03:04,509 --> 00:03:08,859
变成了一个 Web开发者 一个物联网开发者 我在树莓派上跑程序

35
00:03:08,859 --> 00:03:12,249
我在 安卓 iPhone和 苹果手表上跑程序

36
00:03:12,249 --> 00:03:13,929
这么多平台我还在用同一种语言

37
00:03:14,000 --> 00:03:18,405
真棒棒这么多平台   而且他们运行得也棒棒哒 不是吗

38
00:03:21,464 --> 00:03:25,676
总有人问我比如 .net 是否还在增长 是否变差了 为什么

39
00:03:25,676 --> 00:03:30,977
我这里很高兴的宣布我们去年 .net 和 .net core增长了一百万的用户

40
00:03:30,977 --> 00:03:32,705
所以我们干的还不错

41
00:03:32,705 --> 00:03:35,007
重点是我们说的是活跃用户

42
00:03:35,406 --> 00:03:41,147
不是说我们去看了看下载数,下载数特别大 增长了我们就给你们看一个这个方向的累计图

43
00:03:42,249 --> 00:03:47,163
这是实际每天都要开几次VS每周都在做事情的开发者数字

44
00:03:47,163 --> 00:03:52,570
-每次打开VS都超过一分钟, 每月都要打开几次VS的用户  -才算活跃用户

45
00:03:52,570 --> 00:03:56,916
所以说其实还有一百万用户打开了VS写了个Hello World 然后就关掉了

46
00:03:56,916 --> 00:04:03,109
不其实可能有10亿的非活跃用户(现场笑) 一年前开过一次VS就再也没开过了

47
00:04:03,109 --> 00:04:05,803
不确定翻译:*?I'd like think like them as well?*

48
00:04:07,980 --> 00:04:16,916
我们也不知道.net 开园后社区反响怎么样 会有多支持

49
00:04:16,916 --> 00:04:20,371
但是看这个图可以发现 从我们开源.net开始.

50
00:04:20,371 --> 00:04:24,022
 社区对.net的贡献呈现爆炸性增长.我们敲高兴有没有

51
00:04:24,249 --> 00:04:33,616
比如说三星为我们贡献了在ARM32上运行的适配 这是我们现在.net core在树莓派上运行的基础

52
00:04:33,616 --> 00:04:37,020
这是我们在开源后获得社区巨大贡献之一

53
00:04:37,029 --> 00:04:45,981
还有  游戏公司Illyriad 为我们提供了很多性能增强  这也是我们从开源得到的宝贵资源

54
00:04:45,981 --> 00:04:50,289
我们想说一下这个 .net大会

55
00:04:50,289 --> 00:04:55,762
这是一个虚拟的开发者大会.我们这是第一次公开,在今年九月12-14日

56
00:04:55,762 --> 00:05:02,398
我们会有几天的日程 让微软的和社区的群众都来讨论.net

57
00:05:02,398 --> 00:05:04,455
和我们今天要给你们展示的新内容

58
00:05:04,455 --> 00:05:12,043
下面是一条棒棒哒消息: 我们几个月前宣布会有.net core 2.1  RC

59
00:05:13,141 --> 00:05:19,256
今早八点半我们发布了安装包 所以现在你们可以下载了.

60
00:05:19,256 --> 00:05:24,600
今天我会跑几个Demo给你们看  本月我们很可能发布RTM版

61
00:05:24,600 --> 00:05:24,600
这个版本已经相当接近RTM了

62
00:05:27,486 --> 00:05:29,741
这里有很多的改进

63
00:05:29,741 --> 00:05:35,125
其中一大改进是编译更快 运行更高效

64
00:05:35,125 --> 00:05:44,601
你要是使用VS来写和编译.net core 的话 我们一直都很快. 要是用CLI来Build的话性能就差很多

65
00:05:44,601 --> 00:05:54,733
2.1 RTM的时候我们会让两者一样快

66
00:05:54,733 --> 00:06:02,721
第二个大改进 我们修补了(更多不是全部)asp.net core,system.web, Ef core (与.net fx版本)之间的鸿沟

67
00:06:02,758 --> 00:06:05,654
做了很多 还没全做完  可以说是继往开来(观众笑)

68
00:06:06,676 --> 00:06:10,719
啊, 我们继续增强了和.net fx之间的兼容性

69
00:06:10,719 --> 00:06:19,528
我们在nuget建立了一个.net兼容性类库包,里面加入了Directory Service 啊 Imaging啊这些.net fx类库的支持,

70
00:06:19,528 --> 00:06:25,879
我们已经注意到了 欧盟的 general data protection regulation (gdpr)全球数据保护法规 并且在asp.net core全部支持.

71
00:06:26,594 --> 00:06:31,049
我们也创建了一些很cool的微服务模板,稍等我给大家演示

72
00:06:31,049 --> 00:06:37,019
所以说现在呢 大家快点安装然后给我们反馈 我们就可以尽早(找到问题改正)发布正式版

73
00:06:37,440 --> 00:06:41,842
一开GDPR 我就得整天按ok了...

74
00:06:41,842 --> 00:06:47,584
我打算在GDPR的对话框里面加一个挖矿程序

75
00:06:47,584 --> 00:06:51,931
以后可能会有个浏览器增强插件什么的帮你们点GDRP的ok啥的

76
00:06:51,931 --> 00:07:01,030
这图可以看到我们2.1RC  2.1 preview 和2.0 增量编译一个大Web 应用速度的对比.

77
00:07:01,003 --> 00:07:08,025
可以看到速度提高到4-5倍这个速度级别了

78
00:07:08,025 --> 00:07:09,843
这里需要指出一个重要的细节

79
00:07:09,843 --> 00:07:18,784
在你使用.net core的时候 你会对sdk 和runtime 版本有所选择和依赖但是还想要新版本的速度.

80
00:07:18,784 --> 00:07:26,217
为了这些工具的速度你其实没必要把你的解决方案升级到2.1

81
00:07:26,217 --> 00:07:33,016
你可以用2.1 的工具链 用4-5倍的速度编译 然后结果仍然可以在2.0上运行

82
00:07:33,016 --> 00:07:36,118
说滴对

83
00:07:36,118 --> 00:07:45,418
这又是个high点:几年前我们参加了这个Tech and Power的性能比拼

84
00:07:42,048 --> 00:07:45,449
想让.net core 成为前几名

85
00:07:46,376 --> 00:07:49,540
2.1 版我们又更进一大步.

86
00:07:49,540 --> 00:07:53,514
这边特别high,就是数据这一块

87
00:07:53,514 --> 00:08:04,102
你看这边这个测试用例 基本上是数据访问的一个场景.我们可以看到我们升级版本后毛估得到了123%的性能提升

88
00:08:04,102 --> 00:08:08,755
这性能提升涵盖  PS MYSQL和 SQLServer

89
00:08:08,755 --> 00:08:14,138
对所有这些数据库2.1的性能都大大的提高了

90
00:08:14,138 --> 00:08:18,846
讲一下上下文: 左边那个纯文本的意思就是啥也不干

91
00:08:18,846 --> 00:08:23,465
啥也不干很容易 直接返回文本你可以很流畅

92
00:08:23,465 --> 00:08:30,878
比如说我们返回同一个Hello world 用企业级容器化的app 我们可以返回200万次

93
00:08:39,888 --> 00:08:36,342
但是真的做一些真的工作的时候 我们提升了一倍多的效率

94
00:08:36,342 --> 00:08:39,880
大概到了20多万的水准

95
00:08:39,880 --> 00:08:44,821
在 Tech and power 那个测试里我们数据访问现在跑到了前五

96
00:08:45,133 --> 00:08:47,542
横跨所有的技术栈 爽!

97
00:08:47,542 --> 00:08:51,109
这是是一个我们2.1改进的快速总结

98
00:08:51,027 --> 00:08:57,578
全局工具是我最喜欢的改进之一 你现在可以用CLI 的 Nuget直接安装

99
00:08:57,578 --> 00:09:12,047
Span 帮我们节省内存,我们基于这个类型重新写了套接字层, 导致核心性能大幅度提升.

100
00:09:12,047 --> 00:09:19,701
HttpClient 无论是发送还是接收数据 都比以前快了10倍

101
00:09:19,849 --> 00:09:27,237
Windows 兼容包,如我们刚才说的 增加了很多你以前在.net fx使用的类库

102
00:09:27,237 --> 00:09:36,784
这里要加一些评论. 如果你想研究.net底层如何运行的话

103
00:09:50,057 --> 00:09:50,146
你去搜索一下Span你会发现这是从未有过的底层变革, 这是你可能从未听说过的大变化

104
00:09:50,146 --> 00:09:56,205
好像一个车辆的引擎 , 你把它换成混合油,换成油电混合, 还是这辆车

105
00:09:56,205 --> 00:10:04,361
我们基本上把一个丰田车的发动机换成了特斯拉的 可以让大家生活更美好

106
00:10:04,361 --> 00:10:09,578
对于底层开发者 这个可以给你长经验 对于上层开发者 速度很自然的就变得更好了 非常爽

107
00:10:09,578 --> 00:10:13,950
我们不在拷贝那么多内存了 实际上我们现在重用内存

108
00:10:13,950 --> 00:10:15,716
-特别可爱   -是啊

109
00:10:15,716 --> 00:10:19,596
懒加载,EFCore的用户很早就要求我们实现.

110
00:10:19,596 --> 00:10:23,213
现在asp.net core 默认含有了 Https支持

111
00:10:23,213 --> 00:10:30,094
而且我们现在可以吧Razor UI编译成类库了

112
00:10:30,094 --> 00:10:40,648
稍等我们会演示这个 HttpClientFactory, 这个可以在全局设置你的重试逻辑,你将不用在自己的逻辑代码里面来分别实现.

113
00:10:40,648 --> 00:10:44,775
我们还加入了asp.net core的 SignalR  稍等我们也会演示

114
00:10:44,775 --> 00:10:47,090
演示演示演示

115
00:10:47,090 --> 00:10:55,866
今天早上我们打算宣布(可能我们是今天第一个宣布的) 我们现在Azure上有一个SignalR 的服务了

116
00:10:55,866 --> 00:10:57,515
如果你有一个大型的基于SignalR的App,

117
00:10:57,515 --> 00:11:09,436
后台依赖一些其他Azure服务的话,你现在可以把SignalR 也当成服务来用了,它支持几千个连接

118
00:11:09,436 --> 00:11:16,332
几万几十万个连接 可以通过azure来scale out. 稍等我们会给你们看这个演示

119
00:11:16,332 --> 00:11:26,049
实际上我和我的同事Greg一起写了一个站点 和一个Xamarin App,  我们在不同的地点手动的加了一些 SignalR Hub,

120
00:11:26,049 --> 00:11:32,294
现在用SR as a Service  可以让这个应用迅速的Scale Out.

121
00:11:32,294 --> 00:11:34,464
用抽象的接口重构.

122
00:11:34,464 --> 00:11:39,673
另一个要快速说一下的功能是.net core现在支持ARM32,

123
00:11:39,673 --> 00:11:50,724
ARM32 现在也有SDK了 你可以直接在树莓派上面安装

124
00:11:50,724 --> 00:11:58,898
之前我们因为只能在Windows上编译后发布到树莓派被诟病.

125
00:11:58,898 --> 00:12:06,204
现在经过社区Perter Marker  现在我们有各种ARM本地的工具链了.在树莓配上虽然很慢 但是仍然很棒

126
00:12:06,204 --> 00:12:08,760
-今天早上我们宣布了Azure IOT   - 是

127
00:12:08,800 --> 00:12:11,428
他们中一部份工作是用.net core编写的

128
00:12:11,428 --> 00:12:20,883
三星将这些适配到了ARM32  而且很酷的是2018所有三星新出品的电视都能运行.net core了.

129
00:12:20,883 --> 00:12:29,219
实际上到时候你看到TV的启动页面都会是Xamarin Forms实现的 也是运行在.net core上的.

130
00:12:29,219 --> 00:12:35,785
总而言之你们可不要跑到百思百 看到电视就往上贴.net core的不干胶好吗.

131
00:12:36,910 --> 00:12:40,091
无论如何不要这么干啊 因为不干胶弄不干净的(严肃脸)

132
00:12:40,091 --> 00:12:42,620
也别问我为啥知道 ┑(￣Д ￣)┍

133
00:12:42,620 --> 00:12:46,163
-好的现在切到第七个频道  -是的长官

134
00:12:48,087 --> 00:12:55,477
我们快速过一个演示  这是一个SignalR的Web,我们今天发布了这个技术的云服务.

135
00:12:55,477 --> 00:13:02,288
如果我有了一个SignalR App,我要做的就是,调用这个新方法.

136
00:13:02,288 --> 00:13:07,164
Add Azure SingnalR. 然后在下面这

137
00:13:07,164 --> 00:13:11,133
我可以改成  Use Azure SignalR

138
00:13:11,133 --> 00:13:17,286
这就改完了 然后这个App就可以在本地运行但是连接到云端的SignalR Hub了

139
00:13:17,286 --> 00:13:19,555
我们快速看看这边代码什么样.

140
00:13:19,555 --> 00:13:25,688
给不知道的人交代一下  SignalR是一个能够对千万个客户端进行收发消息的服务.

141
00:13:25,688 --> 00:13:31,317
我们打算做一个小测验的App,这边有一个方法 推送问题

142
00:13:31,317 --> 00:13:37,852
你能看到在这里他拿到一个问题 然后推送到所有连接到这个服务的客户端.

143
00:13:37,852 --> 00:13:40,905
这就是SignalR工作的方式

144
00:13:40,905 --> 00:13:45,295
大家都可以连上来 然后就可以形成一个通信通道

145
00:13:45,295 --> 00:13:48,130
好现在让我们来试试

146
00:13:48,480 --> 00:13:53,648
我们现在需要先创建一个管理员控制台创建问题发送

147
00:13:53,648 --> 00:14:00,831
SignalR使用WebSocket 和所有现代浏览器的魔法设施

148
00:14:00,831 --> 00:14:06,252
让我先启动Admin站点啊   我知道我想看看能不能工作

149
00:14:06,252 --> 00:14:10,395
我们从来没在一千人的现场测试过

150
00:14:10,395 --> 00:14:14,292
- 那我先启动管理员控制台  -好的

151
00:14:14,292 --> 00:14:17,319
-小测验   - 嗯小..测验

152
00:14:17,319 --> 00:14:20,719
我们现在要做的是,我们打开Azure的门户

153
00:14:20,719 --> 00:14:24,837
-我这里有一个AppService叫做实时小测验 -对

154
00:14:24,837 --> 00:14:28,387
- 我们来Build一下   -酷

155
00:14:28,387 --> 00:14:34,318
-这里是URL  -缩放?  - 好我给大家放大一下

156
00:14:34,318 --> 00:14:36,888
来打开这个站点

157
00:14:36,888 --> 00:14:43,373
这有点压力测试的意思, 搞不好我们还可以看看.net core异常是什么样子

158
00:14:44,266 --> 00:14:50,323
(观众笑)(清嗓子) 一千多人的时候 正在启动过程中进来可能会卡然后出错

159
00:14:50,323 --> 00:14:55,091
- 我们应该拜拜 或者波浪传递什么的

160
00:14:55,091 --> 00:14:58,576
我今天早上问他 你这压力测试了么他说 嗯测了  四五个人吧

161
00:14:58,576 --> 00:15:03,642
15 20 .22. 26.. 25. 35...

162
00:15:03,642 --> 00:15:06,561
是的你可以实时看到有多少人点击了URL

163
00:15:06,561 --> 00:15:12,068
- 你可以看到的数字  -网站在Azure上

164
00:15:12,068 --> 00:15:14,888
SignalR Hub 在 SR as a Service上运行

165
00:15:14,888 --> 00:15:17,014
那么怎么来Scale out呢,  怎么来操作啊长官

166
00:15:17,014 --> 00:15:23,959
我要做的事我在Azure上操作... 在这里进这个WebSite...

167
00:15:24,135 --> 00:15:26,135
(压力缓解用广告歌声 SignalR~ Hub~)

168
00:15:26,135 --> 00:15:30,167
我们打开Azure上的 SignalR as a Service

169
00:15:30,167 --> 00:15:36,466
- 在这里.  我在正式修改前想要做的是(scale out)  -150咯

170
00:15:35,839 --> 00:15:41,585
-我们这里有负载单位,这是1k连接的负载单位 - 这会花你20刀

171
00:15:41,585 --> 00:15:44,352
我在这修改 然后把这个滑块一口气拖到10

172
00:15:44,352 --> 00:15:48,890
-一万...   -一万个持续连接可以被维护 -好

173
00:15:49,164 --> 00:15:54,805
现在我们这里有170+网站访客了

174
00:15:54,626 --> 00:15:56,950
*?这帮人累了 不想拿出手机来?*

175
00:15:57,022 --> 00:16:02,340
在管理员控制台,我这可以启动游戏

176
00:16:02,340 --> 00:16:04,671
好的我进入游戏了

177
00:16:04,671 --> 00:16:09,107
现在我就可以开始.net小测验 推送我的问题到客户

178
00:16:09,107 --> 00:16:10,338
宝贝儿咱们走起

179
00:16:10,338 --> 00:16:12,659
哦我收到问题了

180
00:16:12,659 --> 00:16:15,122
.net 机器人腰带什么颜色?

181
00:16:15,122 --> 00:16:21,318
错误答案以爆发的势头在这里增长着(观众笑)

182
00:16:21,446 --> 00:16:24,446
不对啊! 不对.

183
00:16:24,539 --> 00:16:29,595
腰带让我放哪里了@*(#&(!#

184
00:16:29,595 --> 00:16:33,216
挺酷的现在好像有300多玩家了

185
00:16:33,216 --> 00:16:36,567
问题有点low, 找个好点的问题

186
00:16:36,567 --> 00:16:42,786
在.net开源项目(类似.net core的项目) 收到了多少社区贡献?

187
00:16:42,786 --> 00:16:43,929
现在好像连上四百个用户了

188
00:16:43,929 --> 00:16:47,560
好的这个问题已经发送了 各位

189
00:16:47,560 --> 00:16:54,426
对了!    实时哦, 真实时哦(拽ing)

190
00:16:54,426 --> 00:17:02,674
这里要指出一些有趣的重点,他在本地运行他的管理员后台

191
00:17:02,674 --> 00:17:06,068
这个后台和 SR as a Service 进行通信

192
00:17:06,068 --> 00:17:10,468
这样你就没法黑到后台啦!因为丫就不在云上!

193
00:17:10,468 --> 00:17:14,110
现在800左右连接了 我们放最后一个问题吧

194
00:17:14,110 --> 00:17:19,103
可怕的问题呢,这标准是啥来着?   是c#吗?

195
00:17:20,342 --> 00:17:24,119
-我要点OK啦   -你错了   -答案是啥? (观众给答案)

196
00:17:24,508 --> 00:17:30,809
- 你应该问某同事 她是做问题的人 - 我点了ok 打错了,然后网站告诉我.就知道你会错.

197
00:17:30,809 --> 00:17:34,250
- 真可爱    -还不错

198
00:17:34,250 --> 00:17:40,482
今天晚些时候我们会把这个演示发布出来让大家可以自己测测

199
00:17:40,482 --> 00:17:44,164
*? 完全没听懂?*

200
00:17:48,136 --> 00:17:54,548
一次成功了感觉很牛  我们实际做过的负载测试是20个连接

201
00:17:54,548 --> 00:18:01,937
基本上就我们9个人没人两三台机器使劲儿发答案的感觉 能不崩溃我也很开心啊

202
00:18:01,937 --> 00:18:07,617
我下一个要展示的是什么呢

203
00:18:07,617 --> 00:18:12,787
我们现在处于一个API为中心的世界,我们有各种设备的客户端,我们可能有JS的客户端和后台通话

204
00:18:12,787 --> 00:18:21,647
VS主要为了调试UI而设计建造,

205
00:18:21,647 --> 00:18:32,147
这是一个Asp.net core webAPI 工程,我们可以看到有很多路径  UI/Controller什么的一大堆

206
00:18:32,147 --> 00:18:35,787
当你F5的时候

207
00:18:35,787 --> 00:18:42,247
你可以看VS对WebApi的调试支持特别棒 是个404错呢

208
00:18:42,247 --> 00:18:48,707
因为这是个API 不是网页项目所以没有主页. 当然要是有的话肯定更好咯

209
00:18:48,707 --> 00:18:55,967
然后我们就被派去研究怎么解决了.这里要给大家看几个细节

210
00:18:55,967 --> 00:19:03,467
这是一个 asp.net core 2.2 才会带来的microservice原型模板

211
00:19:04,257 --> 00:19:08,817
你可以看到里面只有一个Controller 里面并没有Controllers文件夹

212
00:19:08,817 --> 00:19:11,867
还有一个Program.cs 来启动这个程序

213
00:19:11,867 --> 00:19:14,017
#微# 服务哦

214
00:19:14,017 --> 00:19:16,967
是的我们得多说一下这是个微服务

215
00:19:17,000 --> 00:19:23,030
我们再试试调试这个项目 看看同样的问题是否存在. 你们来看我的App

216
00:19:23,030 --> 00:19:27,369
几个加法方法  类似这样的

217
00:19:27,369 --> 00:19:30,520
对你要做两个数字的加法的话 你需要Azure的力量!

218
00:19:30,520 --> 00:19:37,919
-我打算用 http cli来取代browser运行 -我想要跟他们解释一下生词长官

219
00:19:37,919 --> 00:19:51,319
你展开这边的IIS Express, 里面的WebBrowser不会是IE/Edge 等等, 这里会有一个新浏览器

220
00:19:51,319 --> 00:19:54,009
叫做HTTP CLI.这是一个实验,我们在头脑风暴中

221
00:19:54,009 --> 00:20:00,139
现在我们可以F5一下,和我们刚才的例子一样

222
00:20:00,139 --> 00:01:58,249
你瞅瞅啊 大兄弟.  长官,放大放大哟

223
00:20:04,169 --> 00:20:07,399
现在我们有了这个命令控制台了

224
00:20:07,399 --> 00:20:14,709
-在这里我们输入ls   -等等 先停下, 我们要让子弹飞一会儿...等他们反应...

225
00:20:14,709 --> 00:20:22,383
(此处应有掌声)(还真有)

226
00:20:22,383 --> 00:20:29,963
就好像是教堂里面一样呢..   我们干了什么啊长官 我们怎么在WebApi里面塞了个LS啊!

227
00:20:29,963 --> 00:20:37,293
其实挺酷的 我们做的是,在启动的时候自动 扫描/反射 了你的API

228
00:20:37,293 --> 00:20:40,523
这样就可以将一些诊断信息返回到你的客户端了.

229
00:20:40,523 --> 00:20:41,803
-你还能更棒吗 长官   -能啊

230
00:20:41,803 --> 00:20:48,403
然后我们在这里准备输入,调用你的API方法.:加法 1/2

231
00:20:48,403 --> 00:20:54,963
-然后我们可以看到...  -您写错了 您得写  加法/1/2

232
00:20:54,963 --> 00:21:04,093
-对哦对哦  然后我们就可以从CLI的到结果了 是3  -嗯~~

233
00:21:04,093 --> 00:21:14,833
在这里呢 我可以修改他  我在这里修改成乘法 我先改URL 然后修改代码 -Cool

234
00:21:14,833 --> 00:21:17,083
然后呢我就要保存他

235
00:21:17,083 --> 00:21:21,003
我想跟你说一下乘法溢出和多绑定问题不过没关系你说了算你是经理

236
00:21:21,293 --> 00:21:30,293
这时候我再输入ls命令的时候你可以看到修改的内容自动的被获取了.

237
00:21:30,293 --> 00:21:37,263
-这时候你可以输入 乘法/5/5   - 要不试试二十亿乘二十亿啊

238
00:21:30,293 --> 00:21:37,263


239
00:21:42,130 --> 00:21:46,013
这屋里有人不喜欢CLI 喜欢UI的?

240
00:21:46,013 --> 00:21:54,308
-我觉得我们有UI支持呢 - 不是吧这  好哎 好哎

241
00:21:54,308 --> 00:21:56,426
听见了么,大家的心声

242
00:21:59,372 --> 00:22:03,843
大家都这么问, 我Visual Studio的Visual在哪里呢,我买的是 Visual Studio 不是 CLI Studio

243
00:22:03,843 --> 00:22:07,990
感谢Microsoft 和CLI 把DOS带回来

244
00:22:07,990 --> 00:22:11,441
所以一样的体验和UI

245
00:22:11,441 --> 00:22:14,980
我们让Micro Service 默认支持SwaggerUI

246
00:22:14,980 --> 00:22:19,397
- 所以这是原型? -原型  -你们想要吗?  (yeah!)

247
00:22:19,397 --> 00:22:35,252
你有了一个可以用来调试webapi的CLI浏览器原型!

248
00:22:27,558 --> 00:22:32,120
你有了...  对不起我太激动鸟

249
00:22:32,120 --> 00:22:36,876
最后加点东西这个话题结束.

250
00:22:32,120 --> 00:22:39,497
和你平时的体验一致 你可以在UI加断点

251
00:22:39,497 --> 00:22:43,271
在这里我也可以在启动API的时候进入这个断点

252
00:22:43,786 --> 00:22:46,190
- 超级棒    - 我来这加点价值 (模仿 Keynote2 Scott Gu)

253
00:22:46,503 --> 00:22:49,019
(观众笑)

254
00:22:49,019 --> 00:22:52,587
(Hunter 拿起手机模仿 Hanselman 夹 Mic)

255
00:22:52,587 --> 00:22:56,638
(打闹 别挨骂了)

256
00:22:56,638 --> 00:23:12,023
(无关闲聊)  讲讲Http Client?  (触摸板什么的闲聊)

257
00:23:12,023 --> 00:23:16,716
这是我的Podcast

258
00:23:16,716 --> 00:23:22,461
这是我留在微软的另一个原因我可以有机会宣传我自己的podcast

259
00:23:22,461 --> 00:23:24,394
这就是我的节目

260
00:23:24,394 --> 00:23:28,885
它叫做Hansel 分钟因为我估计时间很离谱,

261
00:23:28,885 --> 00:23:32,910
有的时候我跟别人说可能需要花费30分钟

262
00:23:32,910 --> 00:23:36,322
结果我没做到.后来就被人吐槽说你这是汉塞尔星时间吗?

263
00:23:36,322 --> 00:23:40,301
还是地球时间?  啊..这是一个每集30分钟长度的节目

264
00:23:40,208 --> 00:23:47,774
大概有600多集 因为我的冒名顶替综合征发作,前500集就是垃圾

265
00:23:47,774 --> 00:23:51,893
但是后面100集我自我感觉还不错哦

266
00:23:51,893 --> 00:23:56,119
这个站点完全运行在asp.net core 2.1

267
00:23:56,119 --> 00:23:59,535
我跟着日常Build 一起更新  预览1 预览2 预览3

268
00:23:59,535 --> 00:01:58,249
-我没有测试    -你有Razor 页面呢  -是的我也有 Razor Page 这玩意可爱呢

269
00:24:04,818 --> 00:24:05,269
我没有测试代码  这里头有点复杂

270
00:24:10,108 --> 00:24:16,736
我在这里有好多逻辑代码,处理我以前版本系统使用的一种技术 Web Matrix:  asp.net pages

271
00:24:16,736 --> 00:24:19,950
这是个12年的老Podcast项目 代码12岁那么老

272
00:24:19,950 --> 00:24:26,256
我把 web matrix的全部页面 直接适配到 asp.net core 的razor 页面只花费了我一个周末

273
00:24:26,701 --> 00:24:32,883
也就花了4小时的打字时间, 4小时堆栈溢出 (排错)  (群众笑)

274
00:24:33,647 --> 00:24:38,910
我人特好,我今天早上帮他适配到 asp.net core Rc

275
00:24:38,910 --> 00:24:42,662
- 是不错   -嗯 现在是RC了

276
00:24:42,662 --> 00:24:51,523
我这里要做一些基础测试, 因为我用了razor page 我可以用Page模型调用这个函数 on get

277
00:24:51,523 --> 00:24:54,057
在这里面我没有用Http

278
00:24:54,057 --> 00:25:01,441
我又不是测http. 我在做单元测试 我的单元是  "嘿,get工作不"

279
00:25:01,441 --> 00:25:11,416
如果我啥都没输入到onget里面 我应该能够得到返回,而且应该有16页  一共620个返回

280
00:25:11,416 --> 00:25:13,965
这很方便, 但是这不真实啊.

281
00:25:13,965 --> 00:25:16,236
这其实没有Http协议在测试里啊.

282
00:25:16,249 --> 00:25:22,504
我需要更多的功能性测试, 所以这里我们加了更多新酷功能

283
00:25:22,504 --> 00:01:58,249
我们有 WebApp Factory类型. 这里写了ServerFactory 作为其继承,并且指向了StartUp的逻辑.

284
00:25:31,414 --> 00:25:35,670
这样等与在没有实际上启动我的web应用的情况下 启动了我的web应用.

285
00:25:40,479 --> 00:25:40,479
因为测试有不同层次, 单元测试 高一点的是功能测试, 最后是全功能集成测试

286
00:25:40,479 --> 00:25:47,339
这不是集成测试,那种都是开个浏览器,然后用测试工具和VS与浏览器通信操作

287
00:25:47,339 --> 00:25:52,279
这是在单元测试和完整端对端测试中间的一层测试

288
00:25:55,431 --> 00:25:55,431
所以我这里写,嘿,我要用Localhost作为域名

289
00:25:59,933 --> 00:26:03,332
我想使用这些环境,但我不用http  这不会真的连接任何网络  这完全在内存中

290
00:26:03,270 --> 00:26:08,203
这里我们声明我们要一个测试的模拟.没问题

291
00:26:08,203 --> 00:26:12,480
在这里我要请求一个客户端  和一个服务器

292
00:26:12,480 --> 00:26:19,719
然后我就可以对客户端说 嘿 我要这个地址  我们输入一个斜线

293
00:26:19,719 --> 00:26:22,517
这是我们说 这个最好给我返回个200 OK,

294
00:26:22,517 --> 00:26:27,307
这是非常简单简单的测试,我这里还可以做更酷的 我想访问一个节目,

295
00:26:27,307 --> 00:26:30,973
这时候我可以对Server说给我一个符合下面条件的客户端.

296
00:26:30,973 --> 00:26:33,091
因为各种测试都有不同的需要

297
00:26:33,091 --> 00:26:41,646
比如说我要访问localhost告诉他我需要访问624号节目的时候 我要客户端标记禁止服务端返回自动转向指令

298
00:26:41,646 --> 00:26:43,818
这样我就可以测试这个要求了.

299
00:26:43,818 --> 00:26:51,656
这时候我要他访问 624这个url, 这时候我要他断言 是否返回了永久移动的代码

300
00:26:51,656 --> 00:26:55,987
如果我在这里设置成true,我就测不到会不会返回永久返回这个细节了.

301
00:26:55,987 --> 00:27:06,051
这一切呢 其实都放到了我们内存中运行, 测试了我们炫酷的中间件startup.cs配置的网站.

302
00:27:06,051 --> 00:27:14,326
我现在在用vs code. 我很想试试我能用多久不会感到痛苦(死忠Vs粉)

303
00:27:14,326 --> 00:27:21,377
我安装了这个社区提供的测试插件,可以运行测试.

304
00:27:21,377 --> 00:27:27,438
然我们看到这个测试失败了,那必然是因为我是个经理不是程序员(大雾)

305
00:27:27,438 --> 00:27:32,665
然后我们打算点这个 然后在这里  运行

306
00:27:32,665 --> 00:27:39,135
我可以用这个工具独立运行每一个测试, 另外的方式会将我所有的测试全部都运行

307
00:27:39,135 --> 00:27:43,323
那就是在这里用标准的Action方式,

308
00:27:43,323 --> 00:27:45,139
然后滚动一堆消息, 运行测试

309
00:27:45,139 --> 00:27:50,941
我还插入了一些其他插件,这些开源的东西合起来让这个.net测试体验更好

310
00:27:50,941 --> 00:27:57,123
你看我这有一个.net 测试浏览器.(还是失败了) 哇 我真是个差劲程序员.

311
00:27:57,123 --> 00:28:02,023
我会找到哪里错了...  额...

312
00:28:02,023 --> 00:28:05,437
让我有点忧桑,因为我现在搞不清楚为啥. 但是!

313
00:28:05,437 --> 00:28:10,113
现在我们可以做的(强行忽略错误) 是我们可以看我们的测试覆盖率

314
00:28:10,113 --> 00:28:22,751
在测试的时候Coverlet插件会产生运行覆盖的行号所以我们可以看到代码中那些地方被测试跑过了.

315
00:28:22,751 --> 00:28:30,151
哪里没有. 所以 单元\功能\集成测试这些不同级别的测试,是asp.net core 2.1带来的非常好的功能

316
00:28:30,151 --> 00:28:33,506
如果你学会了这些,可以写出很多甜美的测试,

317
00:28:33,506 --> 00:28:42,176
还可以用开源的插件来扩展,比如.net 测试浏览器, Coverlet 或者其他的东西, 比如Open Cover 等等等等

318
00:28:42,176 --> 00:28:45,501
体验非常好 每样东西配合得非常好

319
00:28:45,501 --> 00:28:49,575
除了我这个单元测试 到底为啥错 我很困扰啊...

320
00:28:49,575 --> 00:28:51,469
我打算  (台下支招中) 啥?

321
00:28:51,469 --> 00:28:54,371
("你丫没存啊")  啊 你们这些变态程序员...

322
00:28:54,371 --> 00:28:55,811
(观众笑)

323
00:28:55,811 --> 00:01:58,249
我想鄙视一下 这有一千多人 刚才就没有人提醒我一下,任由我孤立无援风中凌乱.

324
00:29:02,835 --> 00:29:05,436
但宝宝坚强 宝宝不哭 宝宝不恨 没关系.

325
00:29:05,436 --> 00:29:08,300
给开发者做演示比其他的危险啊

326
00:29:08,300 --> 00:29:13,514
是啊 都说是结对编程, 这边看起来是结伙编程.  好

327
00:29:13,514 --> 00:29:17,226
跟一群完全没有帮忙意思的帮伙编程呢! 我看还成.

328
00:29:17,226 --> 00:29:19,804
所以, 谢谢啊~!

329
00:29:19,804 --> 00:29:22,280
啊呀,可以了  现在我们其他测试都是问号了.

330
00:29:22,280 --> 00:29:24,058
酷  好棒啊(虚弱)

331
00:29:26,397 --> 00:29:28,319
所以 单元测试是一个乐趣了.

332
00:29:28,319 --> 00:29:32,002
好的 现在你来? 你要按两下这个按钮

333
00:29:32,002 --> 00:29:34,773
-这样就欧了   -OK

334
00:29:34,773 --> 00:29:39,822
-今天早上我们上台之前刚有一篇blog 发出来  -啥?

335
00:29:39,822 --> 00:29:42,130
我知道这很疯狂

336
00:29:42,130 --> 00:29:48,700
我们发表了.net core 3 的路线图 你知道我们刚开始发布 2.1 RC

337
00:29:48,700 --> 00:29:53,459
有趣的是 我们刚开始搞这个的时候我们以为一年会出一个主版本

338
00:29:53,459 --> 00:29:54,746
结果三年才一个版本?

339
00:29:54,746 --> 00:29:58,572
换我就每周一个新版本!

340
00:30:01,405 --> 00:30:07,363
本来是打算一年一个版本的 但是我们放入太多 太重要的东西了

341
00:30:07,363 --> 00:30:14,842
这里我想说的是  在.net core 2我们主要放入了对网站和云这两个重要部分的支持,

342
00:30:14,842 --> 00:30:23,077
在.net core 3里面我们放入了 桌面 放入了 IOT和 AI支持

343
00:30:23,077 --> 00:30:26,634
在合理谁用 Winform 和WPF

344
00:30:26,634 --> 00:30:34,290
我的老伙计们在哪? 来啊 ok 这有几个.

345
00:30:34,290 --> 00:30:42,033
这些年总有人问这些东西还活着吗 会不会继续发展 是的他们活着还发展了 会在.net core3上运行

346
00:30:42,033 --> 00:30:45,378
-所以..  - 让子弹飞一会儿..

347
00:30:45,378 --> 00:30:50,398
(鼓掌)

348
00:30:50,398 --> 00:30:56,175
如果.net Core 运行在Winform的底层 世界将会怎样?

349
00:30:56,175 --> 00:31:02,911
我们可以用一辆车来打比方 用着还可以的一辆车 我们把它的引擎换成一个好强大的

350
00:31:02,911 --> 00:31:04,172
你仍然还知道怎么用这辆车

351
00:31:04,172 --> 00:31:07,648
-现在我们给你们看看什么叫 好\强\大. -好棒棒

352
00:31:07,648 --> 00:31:12,554
这里要说一下  Winform的WPF当然都支持

353
00:31:12,554 --> 00:31:19,605
我们这周发布了一些消息  XAML道 可以在Winform/WPF里面承载UWP

354
00:31:19,605 --> 00:31:24,961
如果你有一个很棒的UWP控件 你现在可以用它 我们稍等会给你们演示.

355
00:31:24,961 --> 00:31:32,178
XAML 控件,我们会把一些最受欢迎的UWP控件放在Winform/WPF的工具箱里面

356
00:31:32,178 --> 00:31:38,439
- 你拖出来就可以用  -所以会直接在Winform和WPF工程的工具箱里面 -是的

357
00:31:38,439 --> 00:31:47,038
高DPI的修补  我们在下一张会有详述  实际上修改这一问题我们需要对Winform的底层实现进行大改动

358
00:31:47,038 --> 00:32:00,928
所以 side by side 的.net core可以让我们不影响原有的.net情况下side by side的对此进行修改支持.

359
00:32:00,928 --> 00:32:05,118
我要在这里暂停几秒钟 说一下为什么sbs这个功能这么重要?

360
00:32:05,118 --> 00:32:09,648
.net framework很棒 , 但是如果你对他有点怕怕,

361
00:32:09,648 --> 00:32:14,798
如果你所在的组织或者开发者对其中有一点点恐惧 如果一个版本升级了 可能会修正一些东西 或者搞残一些东西

362
00:32:14,798 --> 00:32:22,478
那么要不要把你的非常重要的Winform/WPF App做成不依赖外部文件的自举发布?这就是3.0提供的重要内容

363
00:32:24,788 --> 00:32:35,738
所有的Win32 API和 WinRT API都可以被.net core 调用 下一个演示是关于.net bundler

364
00:32:35,738 --> 00:31:41,398
如果你建立一个winform app你可以决定是否预编译这个app.

365
00:32:39,738 --> 00:32:47,608
我们可以将所有需要的 winform wpf .net core 类库全部链接在一起, 将他们变成一个单独的exe

366
00:32:47,608 --> 00:32:50,708
演示演示演示 不要幻灯片 没人要看幻灯片.

367
00:32:50,708 --> 00:32:59,558
有人可能要问了 为啥不增强,net framework的wpf 和winform 其实已经增强了

368
00:32:59,558 --> 00:33:03,568
.nety fx 活的挺好

369
00:33:03,568 --> 00:33:09,958
所有的XAML 岛和其他的UWP控件 他们都会在4.x里面得到一样的支持.

370
00:33:09,958 --> 00:33:19,658
把这些桌面成员放到core的原因是 你可以有sbs的支持,有用户本地版本和全局版本的多版本.net

371
00:33:19,658 --> 00:33:21,858
其中,开源带来了一件很酷的事情

372
00:33:21,858 --> 00:33:34,028
.net core 底层的core fx /bcl 的性能, 被优化了很多,甚至有很多行为被修改了 很多api也被修了

373
00:33:34,028 --> 00:33:42,608
我们担心这些修改直接加到.net fx会产生很多问题 会让已有的app崩溃,所以core的sbs天性可以让我们轻装上阵 享受更快的bcl而不必担心bcl问题

374
00:33:42,608 --> 00:33:46,168
这样winform和wpf就可以因此占了更多便宜. 稍等给大家看.

375
00:33:46,168 --> 00:33:52,358
如果你是一个 csproj 模型的项目爱好者  你现在也可以在 vs里面添加csproj文件咯

376
00:33:52,358 --> 00:33:55,118
你手写一些东西从 就会变成你的项目定义

377
00:33:55,118 --> 00:34:02,668
我来厘清一下,我们会有一个Winform/WPF App 具有一个新形式的 csproj文件.

378
00:34:01,238 --> 00:34:03,808
- ok     -向我证明吧长官

379
00:34:03,808 --> 00:34:05,198
没.有.人.相信你

380
00:34:05,198 --> 00:34:07,288
第七个频道  go.

381
00:34:07,288 --> 00:34:11,218
(Visual Studio 广告歌)

382
00:34:11,218 --> 00:34:14,718
我们正在读取Build Demos

383
00:34:14,718 --> 00:34:20,218
(电梯等候音乐)

384
00:34:20,218 --> 00:34:22,808
我们看那个之前,我们先....

385
00:34:22,808 --> 00:34:27,558
你得...@#*@#)(@!*)   给他们看但是不给他们讲...7@&#^*&@!^*#

386
00:34:27,558 --> 00:34:29,668
我有两个版本的同一个app

387
00:34:29,668 --> 00:34:32,548
我有一个名叫 Pie Sample的版本

388
00:34:32,548 --> 00:34:38,028
我们检索硬盘上的文件夹,然后用饼形图表示出来大小

389
00:34:38,028 --> 00:34:42,208
我有一个版本运行在.net fx,一个版本运行在.net core

390
00:34:42,208 --> 00:34:47,358
我们先来运行一下.net fx版本

391
00:34:47,358 --> 00:34:52,018
点这里 设置为默认启动项

392
00:34:52,018 --> 00:34:59,758
我做这件事的时候您需要注意的是  这是一个Winform 应用

393
00:34:59,758 --> 00:35:03,698
这里面有几个控件

394
00:35:03,698 --> 00:35:06,938
我们这里放了 Telerik 的控件

395
00:35:06,938 --> 00:35:12,038
- 你要做的事情就是在这里输入文件夹路径  -反斜杠?

396
00:35:12,038 --> 00:35:17,168
输入一个路径 然后点运行

397
00:35:17,134 --> 00:35:19,124
然后它就在路径里面找所有的代码文件

398
00:35:19,124 --> 00:35:21,704
然后在这里显示一些内容

399
00:35:21,704 --> 00:35:23,914
然后就显示这个控件了.

400
00:35:23,914 --> 00:35:30,024
点这些饼你可以看到是哪个文件夹, 尺寸是多少

401
00:35:30,024 --> 00:35:32,734
挺酷哒. 然后我们到这里看

402
00:35:32,734 --> 00:35:36,764
我们切换到.net core 版本

403
00:35:36,764 --> 00:35:41,984
我们之前说过csproj 的样式变了 这是新的样式

404
00:35:46,943 --> 00:35:50,013
这里有几条东西了解一下  这里声明了 Winform

405
00:35:50,013 --> 00:35:53,473
-这里指定了包的版本    -这里还有alpha呢

406
00:35:53,473 --> 00:35:55,763
- 而且这里还有    -这些是特么啥!!

407
00:35:55,763 --> 00:36:01,743
我随机找到了一些 Telerik 的控件 我就放在这了

408
00:36:01,743 --> 00:36:04,223
- 那肯定是买过授权的了   -那必须得了

409
00:36:09,673 --> 00:36:16,973
重点是这个app 运行在已有的控件基础上 没有人花时间精力将旧控件适配到.net core.

410
00:36:16,973 --> 00:36:20,383
所以我们现在开始运行一下

411
00:36:20,383 --> 00:36:22,933
可能有点没意思 因为你们已经看过这个app了

412
00:36:22,933 --> 00:36:26,363
我们会在这里键入同样的路径

413
00:36:26,363 --> 00:36:30,663


414
00:36:30,663 --> 00:36:33,583
你可以看到这里花了200多毫秒

415
00:36:33,583 --> 00:36:36,103
比较刚才之前.net fx 花了500多毫秒

416
00:36:36,103 --> 00:36:37,803
-快了两倍!      -噫!---

417
00:36:37,803 --> 00:36:42,993
winform 快了两倍, 这一改变是免费的吗?

418
00:36:43,463 --> 00:36:44,463
- 免费    -我们应该收费啊!

419
00:36:45,582 --> 00:36:51,662
这些变化源自于  我们对core fx做了一些性能优化

420
00:36:51,662 --> 00:36:54,382
其中一个部分就是新版的文件访问API

421
00:36:54,382 --> 00:37:02,382
新api更好  所以你可以看到至少得到了一倍的速度提升

422
00:37:02,382 --> 00:37:13,322
很多人说你这都是演示 都是假的

423
00:37:13,322 --> 00:37:18,292
所以我们在这里做了一个问号按钮,来展示所有在这里被调用到的dll

424
00:37:18,292 --> 00:37:20,902
是的只要你滚动得够快他们谁也看不清啦. 就不会露馅了

425
00:37:20,902 --> 00:37:31,648
大家看这里 可以发现这里调用的是.net 2.1 库 所以可以看到这个app真的运行在.net core 2,1

426
00:37:31,648 --> 00:37:36,198
好现在我们稍微作死一点.

427
00:37:36,198 --> 00:37:39,258
咱们作 咱们可以死.

428
00:37:39,258 --> 00:37:45,568
我们做了一个.net core 应用,那么我们直接发布他怎么样

429
00:37:45,568 --> 00:37:51,958
我要做的就是右键点这个app, 就像web app一样我找到发布,

430
00:37:51,958 --> 00:37:54,208
这里写着 桌面 单文件

431
00:37:54,208 --> 00:37:57,388
okay cool

432
00:37:57,388 --> 00:38:03,748
下面我们要将这个app 塞入我们的链接器.

433
00:38:03,748 --> 00:38:06,368
我们现在的链接器还不太行

434
00:38:06,368 --> 00:38:08,458
之后会变得更强大

435
00:38:08,458 --> 00:38:13,558
然后他就在我的桌面产生了一个单独的文件.

436
00:38:15,988 --> 00:38:20,208
现在就存在这个U盘上了

437
00:38:20,208 --> 00:38:24,508
这就是我们之前看过的同一个app

438
00:38:24,508 --> 00:38:28,327
(双击了老铁)

439
00:38:28,327 --> 00:38:33,877
耐心之环呢(鼠标图标)

440
00:38:33,877 --> 00:38:37,857
我想给大家看这是一个单文件 66兆

441
00:38:37,857 --> 00:38:41,467
看起来有点大哦 但是我们现在还没有开始优化我们的链接器

442
00:38:41,467 --> 00:38:52,414
但是已经能跟狗展示我们要展示的:WPF/Winform被放在一个EXE里面不依赖任何其他文件

443
00:38:52,414 --> 00:38:59,184
-不够啊    -你就可以用了   -不行啊,  -我们要跟现场观众借一个  -  windows 本子?  windows 本子?

444
00:38:59,184 --> 00:39:03,834
-兄弟你都玩Doom了还没用Windows  好的这个可以

445
00:39:09,734 --> 00:39:15,414
几年前我们把asp.netcore的网站放在一个 u盘上 随便找了个笔记本运行,

446
00:39:15,414 --> 00:39:21,424
今天我们想要做一个一样的演示,不过这次用随机windows

447
00:39:22,184 --> 00:39:26,184
(手机归属权争议)

448
00:39:26,184 --> 00:39:29,964
-帮我插进去 -好了

449
00:39:29,964 --> 00:40:07,037
(切信号中)    "我不喜欢你的桌面"

450
00:40:13,257 --> 00:40:15,257
不要关心那些电影..

451
00:40:15,257 --> 00:40:17,667
双击这个

452
00:40:17,667 --> 00:40:23,817
这是个啥系统 windows 预览每日编译更新还是别的

453
00:40:23,817 --> 00:40:25,327
不是啥特别版本

454
00:40:25,327 --> 00:40:28,377
好的现在我们点浏览 然后选个路径

455
00:40:30,687 --> 00:40:34,687
找一个你不介意公开处刑的路径

456
00:40:34,687 --> 00:40:37,857
好的就这里 cool

457
00:40:37,857 --> 00:40:43,597
然后运行  您这里好多东西啊

458
00:40:43,597 --> 00:40:48,347
多表现一下吗 这个没意思呢.

459
00:40:48,347 --> 00:40:52,467
打开这里 这里肯定有更多有趣的东西

460
00:40:52,467 --> 00:40:54,797
(七嘴八舌开这个)

461
00:40:54,797 --> 00:40:58,507
好滴 这个还像话

462
00:40:58,507 --> 00:41:07,747
这是一个 用teletik控件的   .net core  winfrom 应用  用了一个U盘发布, 啥都不依赖

463
00:41:07,398 --> 00:41:13,867
好的现在我要把这个U盘拔下来 因为没了存储刚才的应用要挂, 祝你好运,

464
00:41:13,867 --> 00:41:17,437
谢谢大兄弟

465
00:41:18,398 --> 00:41:24,377
是不是很酷炫!?

466
00:41:23,696 --> 00:41:26,697
你们也想要这功能吧?

467
00:41:26,697 --> 00:41:34,197
winform 应用.我们可以直接用真的老代码么?

468
00:41:34,398 --> 00:41:38,167
不是说我们这些经理在昨天为今天准备的代码

469
00:41:38,167 --> 00:41:41,447
不是说我们没有为今天努力准备啊.

470
00:41:41,447 --> 00:41:47,277
我就是说说啊 如果有人在飞机上准备一个演示 估计就这个样儿

471
00:41:53,857 --> 00:41:57,376
这一回我们找一些特殊的 特别老的东西

472
00:41:57,376 --> 00:42:01,996
那是有多老

473
00:42:01,996 --> 00:42:09,176
我想我们在vga接口上 大家包涵一下画质啊

474
00:42:09,176 --> 00:42:15,236
我儿子这个月30号就12岁了

475
00:42:15,236 --> 00:42:18,946
有人还记得  吗?

476
00:42:22,146 --> 00:42:25,214
你们中一部分人好像觉得 啊 宝贝乱砸哈哈我孩子都上大学了还能听到这个

477
00:42:26,206 --> 00:42:28,786
另一批的感觉是 谁啊 谁砸宝宝呢?

478
00:42:28,786 --> 00:42:35,146
这是我12年前用来学WPF用的一个App.

479
00:42:35,146 --> 00:42:41,406
我一点按钮就会有图标啊 字母啊 从天上掉下来.

480
00:42:41,406 --> 00:42:47,616
我如字面意义上的12年前写了这个app,我老婆正怀二娃 我大娃就我大腿这么高

481
00:42:47,616 --> 00:42:51,566
我们正在看一部很长的马拉松电影,我没啥干的就写了这个

482
00:42:51,566 --> 00:43:00,966
假设我们啥都不改 直接在上面加一个Xaml内容宿主呢 能不能成呢?

483
00:43:00,966 --> 00:43:08,486
比如说扔进去一个ink组件,在这个app写成的时候这个技术甚至都不存在.

484
00:43:08,486 --> 00:43:12,516
咱们试试

485
00:43:12,516 --> 00:43:15,616
(电梯等待音乐)

486
00:43:15,616 --> 00:43:21,456
这是一个演示XAML 岛的例子

487
00:43:21,456 --> 00:43:23,456
(你说啥? 宝贝乱砸)

488
00:43:27,096 --> 00:43:31,966
我们现在没有声音 但我可以重新来

489
00:43:38,796 --> 00:43:42,916
好的我们现在在宝贝乱砸里面放了一个Ink组件.

490
00:43:42,916 --> 00:43:47,476
它是UWP控件 我们可以在里面放任何东西  web网站什么的都可以

491
00:43:47,476 --> 00:43:52,536
我除了把宿主控件扔进去 什么事情都不需要做.

492
00:43:52,536 --> 00:44:02,346
现在只有宿主,但是将来会有更多牛控件

493
00:44:03,860 --> 00:44:05,086
cool不?

494
00:44:05,086 --> 00:44:09,136
我觉得你们好像不觉特这特别厉害

495
00:44:09,136 --> 00:44:18,106
- 那也行啊. - Hanselman因为不用改任何代码就可以加入inking感到草鸡激动的

496
00:44:18,106 --> 00:44:19,456
相当不错呢!

497
00:44:19,456 --> 00:44:23,076
这上头还有一个wpf 对话框在整个东西上面 所以

498
00:44:23,076 --> 00:44:24,566
这是真的,你们可以确认一下(卑鄙:不会出现winform盖不住wpf host的状况)

499
00:44:24,566 --> 00:44:27,652
你们要知道 我司演示不做假的(某处传来来自公孙乙己的凝视)

500
00:44:27,652 --> 00:44:30,280
我们都是预录的 (第二道凝视)

501
00:44:30,280 --> 00:44:35,065
忽略我们这些切换 有人得把他的本子处理下

502
00:44:35,065 --> 00:44:39,663
马上就好, 第七频道...

503
00:44:39,663 --> 00:44:43,064
- 我们要看幻灯   -欧克 幻灯 5号

504
00:44:43,064 --> 00:44:47,173
啊 我想我把clicker 掉到洞里了

505
00:44:47,173 --> 00:44:49,007
-试试这个   -ok

506
00:44:49,007 --> 00:44:53,409
我们尖端说一下.net core 3

507
00:44:53,409 --> 00:44:56,447
我们希望能够来得及今年后半段可以发布3.0的preview,

508
00:44:56,447 --> 00:45:01,901
你可以看到在我本子上已经有winform 和wpf应用了

509
00:45:01,901 --> 00:45:05,921
我们今天已经运行了wpf 和winform了 我想我们进度比预想的快

510
00:45:05,921 --> 00:45:11,558
如果让设计器都能正常工作的话 挑战其实不小,所以希望赶得上今年晚些时候预览

511
00:45:11,558 --> 00:45:17,128
core 2.2也会在今年晚些时候发布

512
00:45:17,128 --> 00:45:22,712
生产力 我们会简单过一下

513
00:45:22,712 --> 00:45:31,492
Cassy  Amanda 和 Candra  今天已经就这个方向做过一些介绍了

514
00:45:31,492 --> 00:45:36,374
我们试着在今天早上发布的 VS2017 15.7加了一些生产力增强

515
00:45:36,366 --> 00:45:40,575
加了一些代码 在里面

516
00:45:40,575 --> 00:45:44,640
还有一个我觉得很厉害的地方 (15.8才实装)

517
00:45:44,640 --> 00:45:52,170
编辑器设置/风格习惯 开发者喜欢央视可以设置成规则 将会是一个VS的标准功能

518
00:45:51,856 --> 00:45:59,600
编译器也将支持这些规则. 还有一些酷的东西

519
00:45:59,600 --> 00:46:03,423
你可以把LinQ 转化成Foreach 还可以转回来

520
00:46:03,423 --> 00:46:07,055
我们还有些东西给你们看 我们可以反编译代码

521
00:46:07,055 --> 00:46:11,302
我们可以看到源代码 也可以根据nuget里面的源代码地图找到源代码

522
00:46:11,302 --> 00:39:35,398
还有一些厉害的更新比如我们的测试浏览器现在草鸡快

523
00:46:14,423 --> 00:46:18,202
全新的图标可以快速的显示当前测试进度

524
00:46:18,094 --> 00:46:24,287
(演示演示演示) 这个要我说也很酷啊 VS for Mac 7.5今天也发布了

525
00:46:24,287 --> 00:46:33,341
去年我俩在这,说嘿我们会支持razor 支持js 支持ts,

526
00:46:33,341 --> 00:46:35,034
现在都实装了

527
00:46:35,034 --> 00:46:39,038
我们还说要容器支持  现在.net core的容器支持也实装了

528
00:46:39,038 --> 00:46:46,699
还有Azure函数,所有VS上面的重要支持 我们都在VS for Mac上集成了

529
00:46:46,545 --> 00:46:52,217
基本上是一样的代码 我们放在不同的ide上 所以很相似

530
00:46:52,217 --> 00:46:57,876
从web开发角度 我们可以看到很多改进比如 razor的格式化

531
00:46:57,876 --> 00:47:01,204
我们加入到了 vs for Mac

532
00:47:01,204 --> 00:47:04,081
另外15.8我们给重构部分做了很大的增强

533
00:47:04,081 --> 00:47:10,706
有史以来 从.net和web team产生关系起 你从来没有办法

534
00:47:10,706 --> 00:47:14,389
给一个aspx 或者razor的web文件进行重构 这点15.8会支持

535
00:47:14,457 --> 00:47:18,457
如果你需要docker 工具 以前我们需要你增加一些奇怪的composer项目

536
00:47:18,398 --> 00:47:22,941
我们现在把他去掉了,你现在可以从你平时用的项目启动

537
00:47:22,941 --> 00:47:26,302
Kubemetes 支持 我们稍等也会给你做演示

538
00:47:26,302 --> 00:47:30,429
还有发布到  app service和集装箱

539
00:47:30,429 --> 00:47:33,245
好下面我来做一些演示

540
00:47:34,442 --> 00:47:40,442
-当我们开始时 我会做AKS的演示 -ok

541
00:47:40,442 --> 00:47:46,452
我觉得我会往回退一点 聊一聊.net core 3

542
00:47:53,037 --> 00:47:57,893
ok cool.  有几个新东西

543
00:47:57,893 --> 00:48:03,053
15.7里面  我在这里有几个测试

544
00:48:03,053 --> 00:48:08,664
以前你点了全部运行 你就得等他们全都运行完 根本不知道发生了什么

545
00:48:08,664 --> 00:48:14,149
现在所有的这些测试将会异步地和你通信

546
00:48:14,149 --> 00:48:17,322
现在我将编译这个应用然后跑所有测试.

547
00:48:17,322 --> 00:48:22,920
这里面每一个测试都会异步地告诉你 一切进展如何

548
00:48:22,920 --> 00:48:28,409
进展如何 什么东西通过了什么没通过, 很书湖.

549
00:48:28,409 --> 00:48:35,853
在这里面我只要我想 我就可以跳转看到一些特定的代码

550
00:48:35,853 --> 00:48:41,605
在这里你可以看到所有的好东西 比如codelens告诉你这个代码是否通过测试

551
00:48:41,605 --> 00:41:02,398
这些功能都特别好

552
00:48:44,993 --> 00:48:48,444
我有个方法叫 好像叫GetAsync?

553
00:48:48,599 --> 00:48:51,389
在这呢 好了我们开始

554
00:48:51,389 --> 00:41:11,398
我这里有一些很搞的代码 我对他有点复杂感情

555
00:49:00,442 --> 00:49:00,442
我在这写了对于所有的路由集合中的路由 后面我不太明白原理我就注释掉了

556
00:49:02,046 --> 00:49:02,046
然后我在这里做了一些投射

557
00:49:02,046 --> 00:49:07,467
我说我对这个有点感情复杂是因为有时候Linq运行的特别好 有时候他失败了你却不知道为什么

558
00:49:07,467 --> 00:49:13,011
所以下面我要做的就是选中这个linq 查询

559
00:49:13,011 --> 00:49:15,940
然后你就可以看到这边有个看起来爱帮忙的螺丝起子

560
00:49:16,800 --> 00:49:21,460
很帮忙的螺丝起子很酷 然后把注释去掉 然后

561
00:49:21,080 --> 00:49:25,781
(有用的螺丝起子, 广告混合电梯等待曲 叭叭叭帮得上忙的的经理)

562
00:49:25,706 --> 00:49:29,632
我们看看这谁来了 很有用的螺丝起子上面出来一个有用的电灯泡

563
00:49:29,632 --> 00:49:33,004
电灯泡告诉我很多事情

564
00:49:33,004 --> 00:49:35,584
灯泡告诉我这个 转换为foreach

565
00:49:35,584 --> 00:49:40,372
而且她还给我要改成什么样的智能提示

566
00:49:40,372 --> 00:49:46,899
因为linq让我控制我每一层他干了什么,其实是产生了一个Enumerable 然后

567
00:49:46,899 --> 00:49:49,305
我就可以在这里调用了

568
00:49:49,765 --> 00:49:52,323
有人更喜欢linq 有人更喜欢foreach

569
00:49:52,323 --> 00:49:55,703
但是结果是完全一致的

570
00:49:55,703 --> 00:50:01,685
这是十多个更加智能的重构功能中的一个

571
00:50:11,655 --> 00:50:09,540
如果你没看Cassy的课程你也可以点播. 里面有大量的这方面的改进介绍

572
00:50:10,655 --> 00:50:14,112
现在 回到我的测试

573
00:50:14,112 --> 00:50:16,283
就在这里

574
00:50:20,283 --> 00:50:24,492
我这里有一个一直没有通过的测试

575
00:50:24,492 --> 00:50:32,117
他说这个返回不能为空指针或空字符串.  这相当烦人

576
00:50:28,913 --> 00:50:33,078
我还有一个测试叫做 显示时间是否正确

577
00:50:33,078 --> 00:50:44,498
这里有一个Helper 佳作BusHelper

578
00:50:44,498 --> 00:50:46,975
我想要调试这部分 我实际需要做的是点出一个断点

579
00:50:46,975 --> 00:50:52,798
然后右键选择这个测试,选择 调试这个测试

580
00:50:52,798 --> 00:50:56,108
现在我来看一下运行

581
00:50:56,108 --> 00:51:04,168
BusHelper 的代码其实不是项目的一部分 他是一个依赖项

582
00:51:04,168 --> 00:51:08,291
这东西是从别的地方来的 我们来看看从哪里

583
00:51:08,291 --> 00:51:16,673
BusInfo 和BusHelpers 在一起 他们在一个Nuget包里面 我们回头再找

584
00:51:16,673 --> 00:51:20,448
但是现在在这里我们没有这个源代码

585
00:51:20,448 --> 00:51:24,041
我打算 f11 (单步进入)

586
00:51:24,041 --> 00:51:27,943
(放大 再放大  感受Doge的眼神)

587
00:51:27,943 --> 00:51:32,492
你们的反应是这样的: 他暂停了 我们应该鼓掌了

588
00:51:32,492 --> 00:51:39,946
我再说一次:我们不要你们怜悯的掌声 除非是真心的我们不要

589
00:51:39,946 --> 00:51:48,560
当你下载了一个 nuget包 这些nuget包知道他给了你DLL但是不知道DLL从哪里来

590
00:51:48,560 --> 00:51:53,509
在这种情况下我们怎么做呢

591
00:51:53,509 --> 00:51:58,599
我不要点这里的按钮 我要让他干在这里, 然后我们打算看这边

592
00:51:58,599 --> 00:52:08,413
我们看一下Nuspec 文件, 新的nuspec文件知道代码是从哪里来 而且知道是哪次提交

593
00:52:08,413 --> 00:52:11,905
记得我跟你们说过的吗?别鼓掌了 别!

594
00:52:12,929 --> 00:52:15,657
我要点"下载代码继续调试"

595
00:52:15,657 --> 00:52:22,057
这里有个弹出提示"调试器找到了代码文件"

596
00:52:22,057 --> 00:52:25,776
现在我打算把鼠标悬浮在这个文件上头

597
00:52:25,776 --> 00:52:30,588
文件是可用的.

598
00:52:30,588 --> 00:52:36,339
这里有一点tab的使用小知识 你在这个Tab上点右键选择打开所在的文件夹

599
00:52:36,339 --> 00:52:39,364
这里就是代码文件了

600
00:52:39,364 --> 00:52:48,184
所以我们这里看到我调试的时候通过f11单步自动下载了nuget里面dll的源代码 此处可以有掌声

601
00:52:51,712 --> 00:52:53,442
我们去年演示过这个但是那个是没实现的假演示(谁说不造假来着 玉龙插嘴道)

602
00:52:53,442 --> 00:52:55,865
现在可以用了

603
00:52:55,865 --> 00:53:03,853
现在我想单步调试进入一些其他代码

604
00:53:03,853 --> 00:53:11,233
这里面的一些内容我们没有代码也不在nuget上

605
00:53:11,233 --> 00:53:15,436
那会比较讨厌

606
00:53:15,436 --> 00:53:20,282
我找啊找 找不到 发生了什么 我迷路了呀

607
00:53:20,282 --> 00:53:25,377
oh 不! (翻译腔出没)

608
00:53:25,377 --> 00:53:28,131
用 test explorer 找到你的说的test就行了

609
00:53:28,131 --> 00:53:30,930
有时候你帮我我会感觉很糟糕啊

610
00:53:31,552 --> 00:53:34,416
那种紧张感

611
00:53:34,819 --> 00:53:41,449
如果我要想debug这个 Assert.AreEqual 我需要右键点他

612
00:53:41,449 --> 00:53:43,930
然后选"浏览他的定义"

613
00:53:43,930 --> 00:53:46,900
然后我就可以看到一个且大且可怕的法律声明!

614
00:53:46,900 --> 00:53:50,213
他说:

615
00:53:52,490 --> 00:53:56,182
法律法律法律法律法律法律法律法律

616
00:53:56,182 --> 00:53:58,670
下一个版本法律声明会减少(已知用户体验问题)

617
00:53:58,670 --> 00:54:02,235
-然后会有一条龙在这里是不是?  -嗯

618
00:54:02,235 --> 00:54:03,896
真棒

619
00:54:03,896 --> 00:54:06,298
祝你幸运哦  我点

620
00:54:06,298 --> 00:54:10,843
浏览到定义, 你瞅瞅

621
00:54:10,843 --> 00:54:19,451
我们直接反编了我们想要看(浏览到定义)的代码 因为我们有pdb文件

622
00:54:24,053 --> 00:54:30,563
-怎么打开?  -在快速启动某处附近吧. 我觉得是试验性功能 啥的

623
00:54:31,400 --> 00:54:33,400
等一下, 别让我感觉很无能

624
00:54:33,400 --> 00:54:38,617
不在啊

625
00:54:38,617 --> 00:54:41,843
他在, 高级,

626
00:54:41,843 --> 00:54:45,366
-就在这里 -C# -> 高级 ->开启对反编译后代码的浏览

627
00:54:45,366 --> 00:54:48,898
有啥难的

628
00:54:48,898 --> 00:54:56,615
这里重点是你想debug你就会想要源代码

629
00:54:56,615 --> 00:55:03,576
理想状况是提供程序的人给你nuget包 里面有编译的时候用的代码的位置 这杨你可单步进入任何dll

630
00:55:03,576 --> 00:55:09,178
当然你可以做你想做的事情 我们例子里面有公开的nuget 以及公开代码的git

631
00:55:09,178 --> 00:55:13,388
我们也可以在内部环境用内部的nuget和内部的源代码管理

632
00:55:13,388 --> 00:55:18,540
所以说这里有很多的可能性  想象一下你们在开发企业应用

633
00:55:18,540 --> 00:55:23,447
可能你和我刚才的代码差不都就那么大 大概10个项目

634
00:55:23,992 --> 00:55:30,295
然后我会单步调试进入另一个团队的nuget,从他们的代码服务器拉到代码

635
00:55:30,295 --> 00:55:37,287
然后我们又调试进入到第三个团队的,结果这个团队很坏坏 不给我们代码我们就要用反编的

636
00:55:37,287 --> 00:55:40,528
希罕不? 好滴

637
00:55:42,524 --> 00:55:44,796
再来秀一下 编辑器设置吧

638
00:55:44,796 --> 00:55:47,686
好的现在说说编辑器设置

639
00:55:48,409 --> 00:55:51,409
我觉得编辑器设置是一个很小很强大的功能

640
00:55:51,409 --> 00:55:55,688
功能太强 以至于大家无法理解.

641
00:55:53,836 --> 00:55:56,362
-你等会儿 -等啥  -等开工程

642
00:55:56,685 --> 00:55:59,319
是 我知道 没事的  我不紧张

643
00:56:00,126 --> 00:56:05,533
-你能搞定  -我觉得让大家看到我会打字 这挺重要的

644
00:56:07,316 --> 00:56:12,205
-你这样说好像我不会打字似的  - 你是经理啊, 你管资源的

645
00:56:12,205 --> 00:56:15,451
他甚至有一个带有"降职" 按钮的应用

646
00:56:15,451 --> 00:56:20,009
真是真的 他可不想告诉你们 有次开会的时候

647
00:56:20,009 --> 00:56:22,971
他和Glen 做一个演示的时候

648
00:56:22,971 --> 00:56:28,862
他打开了一个app 然后把Glen的内部ID输进去 然后出现了一个又大又肥的写着降职的按钮

649
00:56:28,862 --> 00:56:33,788
Glen正在做演示呢 他把他的笔记本转给Glen好让他能看到屏幕

650
00:56:35,650 --> 00:56:38,238
上面写着"Glen 降职"

651
00:56:38,238 --> 00:56:41,421
然后他使劲按那个按钮, 说,好好演示啊你!

652
00:56:41,421 --> 00:56:45,003
-你是给大家看那个app吗    -是就是那个

653
00:56:45,003 --> 00:56:47,253
你以为我唬你们呐,亲!

654
00:56:47,253 --> 00:56:50,431
这标着呢! 降职器!

655
00:56:50,431 --> 00:56:54,331
我这是求救啊 救命啊 救命啊

656
00:56:57,330 --> 00:57:01,490
我们为编辑器设定做的事情是右键单击这里

657
00:57:01,490 --> 00:46:20,398
创建新项

658
00:57:03,550 --> 00:57:08,300
这里输入过滤 我要编辑器设置文件 名叫

659
00:57:08,300 --> 00:57:12,510
.editorconfig

660
00:57:12,510 --> 00:57:16,200
这不是微软独有的问题,这是全编程界的问题

661
00:57:16,200 --> 00:57:22,630
这个问题是关于,你喜欢tab,而且你又是你们政权的天降伟人

662
00:57:22,630 --> 00:57:30,450
为了假装对你的热爱他们就可以签入这个编辑器设定了

663
00:57:30,450 --> 00:57:32,460
VS里面各种编辑器都认识这个这个设置文件

664
00:57:32,460 --> 00:57:38,220
你看这个设置  这是个xml设置 他的缩进设置跟野蛮人一样设置成了2

665
00:57:38,220 --> 00:57:41,430
你懂的 就这种设置

666
00:57:41,430 --> 00:57:45,970
但是编译器其实不太关心这个

667
00:57:45,970 --> 00:57:48,030
所以你和FXCop一样设置了规则以后,

668
00:57:48,030 --> 00:57:51,860
(你跟他说 我希望c#这样表现)

669
00:57:51,860 --> 00:57:56,470
这时候你就会觉得 要是你的编译器也和编辑器一样懂得这些规则就好了

670
00:57:56,470 --> 00:58:01,030
那么我们这样做怎么样

671
00:58:01,030 --> 00:58:03,300
我们非常希望大家都讨厌人生

672
00:58:03,300 --> 00:58:07,370
所以我设置了一个禁止使用var关键字的规则

673
00:58:07,370 --> 00:58:11,240
懂了么? 再说一次 救命啊!

674
00:58:11,240 --> 00:58:14,170
额  所以这行基本上是说

675
00:58:14,170 --> 00:58:19,270
这里不能用var. 如果类型显而易见 也不行 别的也不行

676
00:58:19,270 --> 00:58:26,150
然后呢 我把它放在解决方案级别,因为我想让所有人痛不欲生

677
00:58:28,250 --> 00:58:33,630
然后我打算进入...  Control +t,

678
00:58:33,310 --> 00:58:35,720
这边一点  进入OnGetAsync

679
00:58:38,360 --> 00:58:42,200
和我想象的不一样啊.

680
00:58:42,200 --> 00:58:45,540
我应该放在别的路径吗?

681
00:58:45,540 --> 00:58:48,050
搞不清了 应该是给每个人的设置

682
00:58:48,050 --> 00:58:54,130
保存一下 别跟刚才似的 被人吐槽没保存

683
00:58:54,130 --> 00:58:55,470
好像没存哈哈

684
00:58:55,470 --> 00:58:58,380
没事的 没事的 T_T

685
00:58:58,380 --> 00:59:01,300
-我应该编译吗 我该干啥 -应该可以用了啊

686
00:59:01,300 --> 00:59:02,600
我做错啥了啊长官

687
00:59:02,600 --> 00:59:04,440
到你帮我的时候了

688
00:59:04,440 --> 00:59:06,090
已经存了呢

689
00:59:06,090 --> 00:59:09,140
我还以为是个屏幕坏点,看来是一粒灰尘

690
00:59:09,140 --> 00:59:13,730
-这个应该是true 嘛? -是的

691
00:59:13,730 --> 00:59:19,580
我不喜欢演示失败 我不相信失败 我不相信这次演示是个失败

692
00:59:19,580 --> 00:59:26,110
放这嘛? 我要把他们拷贝到到处都是

693
00:59:26,110 --> 00:59:29,230
我才不在乎来

694
00:59:29,140 --> 00:59:32,850
我只想让他工作 然后发布 我不在乎

695
00:59:32,850 --> 00:59:35,340
下回我做app也要到处都弄个设置文件

696
00:59:35,340 --> 00:59:42,310
-改掉 none   -到底啥意思啊你说的玩意

697
00:59:44,800 --> 00:59:46,180
警告?

698
00:59:46,180 --> 00:59:49,180
你上来帮帮我啊

699
00:59:49,180 --> 00:59:52,290
哦我知道了

700
00:59:52,290 --> 00:59:54,190
我们有智能提示啊  真的好棒棒

701
00:59:54,190 --> 00:59:56,180
谢谢啊!

702
00:59:56,180 --> 00:59:59,570
-关掉再开  -关掉文件再开文件

703
00:59:59,570 --> 01:00:04,430
你这么念叨的话 谁也听不见啊

704
01:00:04,430 --> 01:00:11,530
-然后我要干啥, 我了个去  -你要把他拷贝到到处都是

705
01:00:15,850 --> 01:00:19,240
-你对我可真坏啊  -你可以删掉那些文件了  -我就不

706
01:00:21,850 --> 01:00:24,010
宝贝啊 ,我要编译通过, 然后我就要发布咯!

707
01:00:32,225 --> 01:00:34,601
我把这些都搞乱了

708
01:00:34,601 --> 01:00:36,531
嘿!!

709
01:00:36,531 --> 01:00:45,331
现在我可以发布了

710
01:00:47,391 --> 01:00:49,991
酷不酷啊

711
01:00:49,600 --> 01:00:59,286
 VS 15.7 有一个大改进   你想改正的时候你想就改一个 你根不想全都改掉(才怪)

712
01:00:59,286 --> 01:01:01,946
-这是你的? -曾是

713
01:01:01,946 --> 01:01:05,040
现在我们有了一个全部修正选项

714
01:01:09,260 --> 01:01:11,430
现在看看可能的修改建议

715
01:01:11,430 --> 01:01:14,916
然后修改 所有的代码问题

716
01:01:14,916 --> 01:01:17,980
因为呢,会有一个解决方案的全局搜索替换

717
01:01:17,980 --> 01:01:19,840
这永远是个好主意 呵呵

718
01:01:25,170 --> 01:01:29,710
严肃说,这是一个好主意  因为这功能很棒帮 不是简单的替换

719
01:01:29,710 --> 01:01:31,790
这不是ctrl+h 我们已经从这种方式毕业了

720
01:01:31,790 --> 01:01:34,620
是个roslyn分析器

721
01:01:34,620 --> 01:01:37,980
这个可以保证你能编译他产生的代码

722
01:01:37,980 --> 01:01:40,460
代码肯定能用,修改是非破坏性的修改

723
01:01:40,460 --> 01:01:48,170
甚至他在文件中进行这种处理的时候 他都能把修改存入撤销缓存

724
01:01:48,170 --> 01:01:50,760
随时可以用 ctrl+z 重建辉煌

725
01:01:53,262 --> 01:01:56,874
-我觉得能编译啊   -能工作啊 我没修那个测试 我只想让这项目看起来好看

726
01:01:59,944 --> 01:01:59,944
哈 成功了

727
01:01:59,980 --> 01:02:07,033
-那是编译啊  -是啊成了  -但是测试还是深深的陷入了错误

728
01:02:07,033 --> 01:02:10,490
嗯 还有一个特性要介绍

729
01:02:10,490 --> 01:02:13,490
我有一个 API 和一个Web App

730
01:02:13,490 --> 01:02:16,670
然后今天早上你给大家修了一些 AKS (Docker编排器)

731
01:02:16,670 --> 01:02:18,509
我爱Mr K

732
01:02:18,509 --> 01:02:21,521
我们有一个预览版的扩展 大概下周发布

733
01:02:21,521 --> 01:02:29,923
这是 VS 15.7的功能 我们会为所有的.net app增加AKS的扩展

734
01:02:29,923 --> 01:02:32,453
我们可以点这个集装箱编排器支持

735
01:02:32,453 --> 01:02:37,866
- ok   oh我可以选择编排器 然后选择 Kurbernete/Helm 好棒

736
01:02:38,647 --> 01:02:41,853
- 我要这么做了   - 然后奇迹就出现了

737
01:02:41,853 --> 01:02:45,895
-然后  -你在重要的部分开始含混带过了  -没说清楚是吗

738
01:02:45,895 --> 01:02:49,125
然后向我这样 对每一个项目都做一遍

739
01:02:49,125 --> 01:02:56,227
我们项目里面有两部分 一部分Web 一部分API

740
01:02:59,453 --> 01:02:58,679
如果我要发布 我希望能够两个都发布 而不是只发布一个

741
01:02:58,679 --> 01:03:02,121
-是我不好  -所以我给两个都加上了K/M支持  -好的

742
01:03:02,121 --> 01:03:06,524
我们把Chart文件夹放进去 里面有一些元数据,一些模板

743
01:03:06,524 --> 01:03:10,400
这些我们待会细说

744
01:03:10,400 --> 01:03:14,704
wen和steve 现在正好有一个session

745
01:03:14,704 --> 01:03:21,783
是的正好现在在另外一个厅 Glen他们正在将 AKS的事情所以大家不要忘记看重播

746
01:03:21,783 --> 01:03:25,227
-他们会讲这些文件是啥 怎么来使用 -是

747
01:03:25,227 --> 01:03:28,618
当做完这些以后 我这里就会出现这个新的功能

748
01:03:28,618 --> 01:03:31,310
-发布到Azure AKS  -cool

749
01:03:32,828 --> 01:03:37,976
-让子弹飞~一会?  -实际上这个还颇费时间

750
01:03:37,976 --> 01:03:43,626
-这就是为啥这玩意还是个预览版扩展  -预览还行

751
01:03:43,626 --> 01:03:47,111
- 他在挖比特币     - 这完全是 在挖矿呢

752
01:03:47,111 --> 01:03:51,126
这是我们的新策略 发布的时候顺便挖比特币 反正别的也干不了

753
01:03:53,682 --> 01:03:58,473
这边需要我填写的是这边有等待图标的部分

754
01:03:58,473 --> 01:04:00,781
选择我的订阅

755
01:04:00,781 --> 01:04:03,658
我的AKS集群 以及我的容器注册表

756
01:04:03,658 --> 01:04:09,312
一旦我设置好这些 我的APP就可以一键发布到 AKS了

757
01:04:09,312 --> 01:04:12,890
ok  他一般会Build 和其他他常做的事情

758
01:04:12,890 --> 01:04:18,420
-他发布的时候 如果我没理解错的话 是把他推送到容器注册表的对吗 -是的

759
01:04:18,420 --> 01:04:20,757
然后做部署?

760
01:04:20,757 --> 01:04:25,181
- 他会把每个应用当成一个容器发布到容器注册表  -ok

761
01:04:25,181 --> 01:04:28,958
然后他会告诉AKS 到容器注册表里面去拉

762
01:04:28,958 --> 01:04:31,468
我知道容器注册表变化了

763
01:04:31,468 --> 01:04:35,207
然后KAS会把这些影响拉回来

764
01:04:35,207 --> 01:04:38,148
-然后你的应用就可以运行了  -我们现在该多担心呢?

765
01:04:39,527 --> 01:04:41,274
-担心啥   -这个等待图标

766
01:04:43,388 --> 01:04:45,226
-有人担心吗 -你有多担心 (同时)

767
01:04:45,226 --> 01:04:47,602
这取决于观众了

768
01:04:47,602 --> 01:04:54,090
如果这里有人用会议计算器计算成本的话 这很花钱

769
01:04:54,090 --> 01:04:56,711
我觉得我们时间还是有的

770
01:04:56,711 --> 01:05:00,627
(笑场口齿不清)

771
01:05:00,627 --> 01:05:05,270
好吧 这是个预览版的 所以可能会这样

772
01:05:05,270 --> 01:05:11,142
-要我说咱们这个演示到此为止 -不!这个演示必须在你填好后点ok才算结束(不承认失败)

773
01:05:16,223 --> 01:05:17,869
ok  很酷

774
01:05:17,869 --> 01:05:21,579
- 我们先切回到幻灯片  -我们来假装你点了ok吧!

775
01:05:21,579 --> 01:05:23,608
我了个去, 这太棒了!

776
01:05:23,608 --> 01:05:25,320
谢谢你的演示  干的太棒了

777
01:05:36,067 --> 01:05:38,619
我们好像有两个演示哈 你来我来?

778
01:05:40,276 --> 01:05:41,446
好吧我来做这个

779
01:05:41,446 --> 01:05:42,786
.net 机器学习

780
01:05:42,786 --> 01:05:47,076
这是我们今天提到的很激动人心的东西

781
01:05:47,076 --> 01:05:54,556
如果你用.net你又想要用ML,我们有很好的前瞻性服务,有个厉害的服务叫做认知服务

782
01:05:54,556 --> 01:05:58,286
这东西基本上是AI但是为不懂AI的人准备的

783
01:05:58,286 --> 01:06:03,656
这些服务很cool,他们用RestAPI 你给他们喂数据他们就给你结果

784
01:06:03,656 --> 01:06:10,676
如果你还不会用AI 但是你想要用一些已经训练好的模型 这对你来说是非常好的技术服务

785
01:06:10,676 --> 01:06:12,306
我们来看这个感情语言模型

786
01:06:12,306 --> 01:06:17,056
我们这里想要知道这个句子里面的感情如何

787
01:06:17,056 --> 01:06:20,176
这个一般来说会正确识别 这是个好吸尘器

788
01:06:20,176 --> 01:06:22,416
96% 正面的感情

789
01:06:22,416 --> 01:06:25,106
下一个

790
01:06:25,106 --> 01:06:27,686
这个吸尘器真TM能吸

791
01:06:27,686 --> 01:06:34,576
一般来说吸的时候感情是不开心的 (suck表示吸或烂)

792
01:06:31,206 --> 01:06:35,201
但是在这个状况很显然他是个好事,因为这是个好吸尘器 他能吸土

793
01:06:35,201 --> 01:06:40,751
这时候我们的感情分析就会返回 这是一个负面评价 不是个好吸尘器

794
01:06:40,751 --> 01:06:47,091
这个案例告诉我们 预建的模型有时候不能满足你的需要

795
01:06:47,091 --> 01:06:54,141
对于这个情况我们给你的建议是让你们来建立自己的自定义模型

796
01:06:54,141 --> 01:07:00,391
- 准备数据 训练模型  -嘎嘎嘎嘎  - 然后准备...你让我很受伤啊

797
01:07:00,391 --> 01:07:07,181
- 嘎嘎嘎嘎嘎     - 已经有一些AI Lib 可以让你写写实验了

798
01:07:07,181 --> 01:07:11,131
你可以看到有这些 然后今天我们很开心的向你介绍

799
01:07:11,131 --> 01:07:14,481
我们现在有一些新的工具 叫做 ML.net

800
01:07:14,481 --> 01:07:18,151
这些是基于微软自己用了好几年的技术

801
01:07:18,151 --> 01:07:22,051
bing用它 office用它 很多其他的了不起的产品都用他

802
01:07:22,051 --> 01:07:30,771
我们就想 我们技术这么牛为啥不开源 做出API给其他开发者一起用呢

803
01:07:31,651 --> 01:07:39,081
实际上它可以消费其他类库产生的模型 比如Accord TF和CNTK

804
01:07:39,081 --> 01:07:46,071
这是一个启动.我们现在是启动这个项目  我们叫他0.1是有原因的

805
01:07:46,071 --> 01:07:51,111
我想让你们知道的是 这玩意已经在微软内部用了好几年了

806
01:07:51,261 --> 01:07:58,231
-他已经被  我可以说吗?  -数据科学家 我已经说了 bing 和其他牛逼产品  -使用过

807
01:07:58,231 --> 01:08:03,351
我们做的是把这些东西全部弄出来 可能有一点杂乱

808
01:08:03,351 --> 01:08:09,761
我们正在整理,所以你可以看到这是全部的内部的技术  全开源 从底层开始

809
01:08:09,761 --> 01:08:13,541
尝试让开发者能够真的用上Machine learning

810
01:08:13,541 --> 01:08:18,601
记得我本节最开始说的 我怎么从VB6改学winform,

811
01:08:18,601 --> 01:08:22,301
我啥都没做,

812
01:08:22,301 --> 01:08:25,501
我变成了  安卓开发者 iOS开发者 树莓派开发者

813
01:08:25,501 --> 01:08:28,071
你们现在全体都变成机器学习专家了

814
01:08:28,071 --> 01:08:31,141
所以呢 我要你们把这个加到你们简历里面

815
01:08:31,141 --> 01:08:33,431
还要加到LinkedIn的资料里面

816
01:08:33,431 --> 01:08:42,121
本次会议结束后 我希望成千上万的ML专家涌现 虽然他只会按F5运行

817
01:08:42,121 --> 01:08:46,531
我们来转换一下显示

818
01:08:46,531 --> 01:08:47,921
好我们换到7频道

819
01:08:48,291 --> 01:08:55,392
-很多的时候AI的演示都是一些不常用看着很虚的东西,我们不打算做这种 -可不是嘛

820
01:08:55,101 --> 01:09:03,041
明天 欧奇的讲座立案他会给大家介绍三个我们实际会用到的三个AI例子你们可以带回去用的那种

821
01:09:03,041 --> 01:09:05,701
- 这是其中的一个   - 明天讲座里面会说得更深入

822
01:09:05,701 --> 01:09:15,071
现在的情况是 你现在跑到github上发一个issue,会有一个活人帮你分类 这是网络的 那个是asp.net的 这样的标记

823
01:09:15,071 --> 01:09:18,861
我们再想能不能用AI来做这件事情 

824
01:09:18,861 --> 01:09:22,861
我现在准备了一个 GitHub issue准备提交

825
01:09:22,861 --> 01:09:29,145
好 内容是我网站有问题了 我找不到 ClientWebSocket这个类在哪里了

826
01:09:29,145 --> 01:09:32,875
然后 我们打算点这个 提交新的issue

827
01:09:32,875 --> 01:09:37,605
这时候你可以看到这里没有标签 没有负责人

828
01:09:37,605 --> 01:09:42,995
有个活人 他会做这件了不起的事情 帮我们把这样的问题归类

829
01:09:42,995 --> 01:09:45,825
但是这种事已经被活人做了很多年了

830
01:09:45,825 --> 01:09:51,465
实际上我们已经有成千上万这种分类的历史纪录了

831
01:09:51,465 --> 01:09:55,365
这已经是个非常大的数据了

832
01:09:55,365 --> 01:09:59,335
我们从我们的资料库提取了很多年的数据

833
01:09:59,335 --> 01:10:07,515
所以说你要是在这个地方说  你的类库特别能吸土 我们会知道你真的讨厌这个类库

834
01:10:07,515 --> 01:10:12,955
-这是因为我们真的有很多年的数据,我想我们这里有一万个issue  -是的

835
01:10:12,955 --> 01:10:17,505
这些都是被我们的工程师手选的 所以我们这里有非常好的训练数据

836
01:10:17,505 --> 01:10:20,605
我去 这里有1万六千多条

837
01:10:20,605 --> 01:10:24,895
下面就是cool的地方了 我不开玩笑

838
01:10:24,895 --> 01:10:27,525
可能你不是个数据科学家 你要去和你的数据科学家说这件事

839
01:10:27,525 --> 01:10:31,345
数据科学家可以去训练这个,你也可以自己训练这个

840
01:10:31,345 --> 01:10:35,745
我们花了好多时间来训练这个 花了5-10分钟呢!

841
01:10:35,745 --> 01:10:41,675
我们把tsv文件导出 作为模型 变成了一个blob文件

842
01:10:41,675 --> 01:10:44,235
blob就是那个模型

843
01:10:44,235 --> 01:10:46,005
你可以看到在这个文件夹 起名叫做模型

844
01:10:46,005 --> 01:10:52,155
虽然他不是Dll是个blob 但是你可以靠给别人  别人再考给其他人 说这是你要的模型

845
01:10:52,155 --> 01:10:55,335
这是新的模型 我又训练了很多 现在他知道得更多了

846
01:10:55,335 --> 01:11:01,865
下面我要启动这个应用 他会和github进行通讯 找到所有没有打label的issue

847
01:11:01,865 --> 01:11:05,465
然后我可以f11单步进入这个函数

848
01:11:05,465 --> 01:11:07,155
这里程序枚举所有issue

849
01:11:07,155 --> 01:11:12,775
然后他会思考然后标记他们

850
01:11:12,775 --> 01:11:16,645
好的  标记完毕

851
01:11:16,645 --> 01:11:20,555
我们回到 GitHub 

852
01:11:20,555 --> 01:11:22,055
刷了个新

853
01:11:22,055 --> 01:11:19,155
啥也没发生...

854
01:11:26,045 --> 01:11:30,075
这个帖子不够新嘛?

855
01:11:30,075 --> 01:11:38,555
-我们等一分钟  -一分钟  -等一分钟傻  哦我明白了 这是个很有趣的点

856
01:11:38,555 --> 01:11:41,015
我来说清楚一点

857
01:11:41,015 --> 01:11:42,825
我们不想扫描整个系统

858
01:11:42,825 --> 01:11:50,025
- 一般来说这个应用的正确用法是 -我来重发  - 好的我继续

859
01:11:50,025 --> 01:11:54,475
我不是找借口 正确的做法是 按照azure做的方式来做这件事

860
01:11:54,475 --> 01:11:56,705
或者是一个在后台运行的机器人一样来做

861
01:11:56,705 --> 01:12:02,465
用一个web 钩子,就和asp.net web hook 一样的类库

862
01:12:02,465 --> 01:12:06,695
然后根据钩子启动. 我们这里就把这样的逻辑放在一个控制台程序

863
01:12:06,695 --> 01:12:08,335
这个控制程序来进行通信 

864
01:12:08,335 --> 01:12:16,855
这样只要调用这个控制台程序 他就可以隐藏细节调用GitHub和restapi的洗劫了

865
01:12:16,855 --> 01:12:18,835
你看这都运行标签成功了

866
01:12:18,835 --> 01:12:21,595
所以说这个程序只去看最新一分钟内更新的条目

867
01:12:21,595 --> 01:12:24,895
这是一个用于演示的拉数据的例子

868
01:12:24,895 --> 01:12:28,095
请点击刷新 然后放大  让大家看看右下角 长官

869
01:12:28,095 --> 01:12:36,645
好了现在大家看到了

870
01:12:36,645 --> 01:12:42,765
-这就成了  -大家看 现在AI自动把clientwebsocket 分类到了system.net

871
01:12:42,765 --> 01:12:50,535
-所以GitHub上的人就可以用这里的代码直接来为自己的issue进行训练和标记了 -是的

872
01:12:50,535 --> 01:12:56,755
- 这个可以应用到...   -你想你可以用这个程序做什么, 你的博客回复啊,

873
01:12:56,755 --> 01:12:58,515
你CRM里面的信息啊

874
01:12:58,515 --> 01:13:01,825
所有的认知服务能够做的事情通过这种方式都可以为你所有

875
01:13:01,825 --> 01:13:03,645
但这玩意在本地运行

876
01:13:03,645 --> 01:13:06,315
我们本地训练,本地运行

877
01:13:06,485 --> 01:13:10,495
有一个与运行时和底层模型进行交互

878
01:13:10,495 --> 01:13:12,095
来做工作

879
01:13:12,095 --> 01:13:13,755
我可以把它拿出来 然后放在随便什么其他地方

880
01:13:13,755 --> 01:13:18,745
这些都在 ML.net. 你可以在GitHub/dotnet/machinelearning找到

881
01:13:18,745 --> 01:13:20,535
这非常牛 而且会越来越强大,

882
01:13:22,695 --> 01:13:25,875
我们还有点时间 下面的事情甚至更酷

883
01:13:25,875 --> 01:13:28,307
-给我点时间 我重新弄一下   -另一种方式的更酷

884
01:13:29,015 --> 01:13:30,725
-你重置了了么  -嗯

885
01:13:30,725 --> 01:13:33,795
- 我把什么东西隐藏了? -是的 就是你

886
01:13:33,795 --> 01:13:38,435
-ok  我现在说什么  - blazor   - 偶液 blazor. 你们知道blazor嘛?

887
01:13:42,185 --> 01:13:46,905
我们看到javascript变成了internet的虚拟机了对吧

888
01:13:47,155 --> 01:13:53,325
我们见到了一些 编译成js 的其他转译性语言 比如coffee script 和typescript都是

889
01:13:55,046 --> 01:14:01,916
我们也见到了asm.js  作为一种编译形式的js语言

890
01:14:01,916 --> 01:14:08,526
还有 webassembly 作为一种二进制的语言运行时 被所有的浏览器支持

891
01:14:08,526 --> 01:14:17,646
那么试想一下如果你用.net编写你整个的 webui体验会怎样呢?

892
01:14:17,646 --> 01:14:25,616
如果在浏览器里面 webasm上运行的是.net 本net呢?

893
01:14:25,616 --> 01:14:27,446
想想看

894
01:14:27,446 --> 01:14:30,706
-你还在弄演示捏?  -是啊

895
01:14:37,386 --> 01:14:39,806
好的 请放大右下角 长官

896
01:14:39,806 --> 01:14:45,796
你看到 mono.js.   .net有很多不同的分支实例

897
01:14:45,796 --> 01:14:50,146
以前我们说.net 我们指的是 .net FX

898
01:14:50,146 --> 01:14:54,416
我们现在说.net 指的是 .net FX 或者 core 或者是mono

899
01:14:54,416 --> 01:15:00,146
.net core是一个精简版本  运行在十来种linux设备上

900
01:15:00,146 --> 01:15:03,536
它是个优化的 微小版本的.net

901
01:15:03,536 --> 01:15:09,546
mono呢 在历史上是个很强大的实例 它支撑了 Xamarin.

902
01:15:09,546 --> 01:15:14,656
它是个特别易于适配特别干净编译的.net实例

903
01:15:14,656 --> 01:15:17,426
我们把它编译到WASM如何呢?

904
01:15:17,426 --> 01:15:18,606
还真行

905
01:15:18,606 --> 01:15:23,776
所以你们的app其实在浏览器运行  当他在打开这个页面的时候

906
01:15:23,776 --> 01:15:28,386
-再刷一下?  -刷 -你想要再看一次

907
01:15:28,386 --> 01:15:30,316
好的继续 点刷新

908
01:15:30,316 --> 01:15:33,296
好的 这就加载了

909
01:15:33,296 --> 01:15:38,006
我觉得我们.. oh 你看到dll了嘛

910
01:15:38,006 --> 01:15:39,246
向下翻 向下

911
01:15:39,246 --> 01:15:45,386
实际上它下载了DLL. 这些DLL 是编译成.net的

912
01:15:45,386 --> 01:15:52,116
这就是你写的dll, 然后浏览器实际上在运行这些dll

913
01:15:52,116 --> 01:15:56,326
他用了.net standard 2.0 还记得我们说过.net standard多重要吗?

914
01:15:56,326 --> 01:16:00,466
有很多实例的.net  如果你使用standard作为媒介

915
01:16:00,466 --> 01:16:04,356
你的代码可以在 ios 安卓...上运行   现在可以在浏览器了!

916
01:16:04,860 --> 01:16:13,149
如果不支持WASM怎么办? 他会回退会 asm.js  这样可以用js方式运行

917
01:16:13,149 --> 01:16:15,359
但是WASM所有新浏览器都支持

918
01:16:15,359 --> 01:16:23,029
我们在这里看到的是我们在这里写了一个函数onhover.在@function里面的都是c#

919
01:16:23,029 --> 01:16:26,559
他在写c# 一个 on hover 和一个 on not hover

920
01:16:26,559 --> 01:16:30,489
然后他在这写了一个text 他设置了一个字段叫text

921
01:16:30,489 --> 01:16:34,979
然后他需要在上面绑定页面模型字段到页面上的某个位置

922
01:16:34,979 --> 01:16:37,669
所以他可以在这个H1标记里面写

923
01:16:37,669 --> 01:16:41,159
像这种的  @Text

924
01:16:41,159 --> 01:16:42,759
你们用 Razor写这个模板

925
01:16:42,759 --> 01:16:44,449
就在这个浏览器里面

926
01:16:44,449 --> 01:16:47,159
然后我们就在这里也加上 @Text, 那边也加上

927
01:16:47,159 --> 01:16:53,719
理论上你不会只想显示 你也会需要有互动 那么我们加一些互动用的代码

928
01:16:53,719 --> 01:16:55,469
比如 onmouseover

929
01:16:55,469 --> 01:17:00,159
你们看一下这些东西已经变成紫色了

930
01:17:00,159 --> 01:17:07,559
这是一个H1标记已经被运行时 识别的标志

931
01:17:07,559 --> 01:17:18,979
这时候根据客户端的js event, 浏览器实际上 我要强调下 运行了.net客户端事件

932
01:17:18,979 --> 01:17:24,369
-我从html 标记调用了 c#  -从DOM调用

933
01:17:24,369 --> 01:17:25,879
我们来证实一下吧长官

934
01:17:25,879 --> 01:17:28,639
(你写错了)

935
01:17:28,639 --> 01:17:31,879
-你写错了一个地方 你会面临可怕的失败! -我想我找到了好像这里不应该加括号

936
01:17:35,449 --> 01:17:39,809
-你忘记保存了(小声)  (你没写@)  -@不要忘记写啊 @

937
01:17:39,809 --> 01:17:41,619
ok 你们这帮家伙真强

938
01:17:41,619 --> 01:17:44,879
不爽吧 被人纠正

939
01:17:47,759 --> 01:17:50,919
这就是为什么我开始酗酒

940
01:17:52,649 --> 01:17:56,349
ok 我们弄好了吗?

941
01:17:56,349 --> 01:17:57,979
这里我们刷新一下

942
01:17:57,979 --> 01:18:03,669
有些人说了 我才不想下载一兆或者 几兆大的运行时呢.

943
01:18:03,669 --> 01:18:08,169
但是其实,你一般发布一个网站 你的首页上都是一个巨大的png

944
01:18:08,169 --> 01:18:11,659
你们看这个

945
01:18:13,679 --> 01:18:18,979
我们跳到取得数据的页面

946
01:18:18,979 --> 01:18:21,929
点到那里 然后我们看看 获取数据的控件

947
01:18:21,929 --> 01:18:24,779
代码里面 兄弟

948
01:18:24,779 --> 01:18:28,233
好的 打开它 滚动下去

949
01:18:30,873 --> 01:18:33,673
这里调用了http 获取了一段json

950
01:18:33,673 --> 01:18:36,253
这些都是你知道怎么用的.net api

951
01:18:36,253 --> 01:18:37,913
但这是web开发

952
01:18:37,913 --> 01:18:43,403
这是web开发  这不是winform或者其他的 东西

953
01:18:43,403 --> 01:18:48,243
我有c#和.net 的专业素养 我想写web 我想用平时的方式来工作

954
01:18:48,243 --> 01:18:51,243
这就是标准方式的试验版本

955
01:18:51,243 --> 01:18:54,413
我们觉得大家会买账的   你们喜欢吗?

956
01:18:56,863 --> 01:19:02,453
他叫blazor

957
01:19:02,453 --> 01:19:06,733
下面是总结 .net core 2.1 RC的今天可以下载

958
01:19:06,733 --> 01:19:07,993
请领养这个宝宝

959
01:19:07,993 --> 01:19:11,453
ML.net今天也可以下载了 请领养 并且留下宝贵意见

960
01:19:12,803 --> 01:19:18,023
.net3今天宣布对桌面的支持,希望今年晚些时候会有相应预览版本放出

961
01:19:18,023 --> 01:19:22,163
Blazor部分 请试试,然后给我们意见回馈

962
01:19:22,163 --> 01:19:29,482
我们得看看这一张

963
01:19:29,482 --> 01:19:33,352
这些是你们应该要好好看看的 session

964
01:19:33,352 --> 01:19:37,252
hunter他是经理  他不关心你们的反馈

965
01:19:37,252 --> 01:19:40,002
但是这里应该有个QR码

966
01:19:40,002 --> 01:19:41,652
请给我一个特别好的评价

967
01:19:41,652 --> 01:19:46,022
然后给他一些一般般的评价

968
01:19:46,022 --> 01:19:52,892
我会把这些都用情感分析AI跑一下,看看哪个Scott更受欢迎. 结果我会写一个blog , 

969
01:19:52,222 --> 01:19:55,572
看看到底能不能区分出来 <这个Scott 不咋滴  那个Scott 非常棒>

970
01:19:57,132 --> 01:20:00,342
我们拭目以待   大家一定要填写问卷啊 

971
01:20:00,832 --> 01:20:02,782
-非常感谢  -谢谢大家

972
01:20:01,572 --> 01:20:04,572


